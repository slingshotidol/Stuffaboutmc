You'll learn advanced minecraft scripting api or something. Scripts that you've made with me from the past, and me prompting it:

import { world } from '@minecraft/server';

world.beforeEvents.chatSend.subscribe((chatEvent) => {
  const sender = chatEvent.sender;
  let message = chatEvent.message;

  // Example: Respond to a specific message
  if (message.toLowerCase() === 'hello') {
    sender.sendMessage('Hello to you too!');
    chatEvent.cancel = true; // Prevent the original "hello" from showing
  }
});

import { world, EffectTypes, ItemStack } from '@minecraft/server';

world.afterEvents.itemUse.subscribe(eventData => {
  const { source: player, itemStack } = eventData;

  // Check if the used item is a feather
  if (itemStack && itemStack.typeId === 'minecraft:stick') {
    // Add strength effect for 10 seconds, amplifier 1
    player.addEffect(EffectTypes.get("strength"), 200, { amplifier: 1 });

    // Send a message to the player (optional)
    player.sendMessage('You feel stronger!');

    // Remove one feather from the stack, unless there is only one feather remaining.
    if (itemStack.amount > 1) {
        itemStack.amount -= 1;
    }
  }
});

import { world, system } from '@minecraft/server';

world.afterEvents.itemUse.subscribe(eventData => {
  const { source: player, itemStack } = eventData;

  if (itemStack && itemStack.typeId === 'minecraft:feather') {
    // Send "3" (Green) with a 1-second delay
    system.runTimeout(() => {
      player.sendMessage("§a3");
    }, 20);

    // Send "2" (Yellow) with a 2-second delay
    system.runTimeout(() => {
      player.sendMessage("§e2");
    }, 40);

    // Send "1" (Red) with a 3-second delay
    system.runTimeout(() => {
      player.sendMessage("§c1");
    }, 60);

    // Send "Go!" with a 4-second delay
    system.runTimeout(() => {
      player.sendMessage("Go!");
      if (itemStack.amount > 1) {
        itemStack.amount -= 1;
    }
    }, 80);

  }
});

// server.js

import { world } from '@minecraft/server';

world.afterEvents.playerPlaceBlock.subscribe((eventData) => {
  const { player, block } = eventData;
  if (block.typeId === 'minecraft:dirt') {
    player.sendMessage('You placed dirt! Changing it to stone.');
    block.setType('minecraft:stone');
  }
});

import { world, EntityTypes } from '@minecraft/server';

world.afterEvents.entityHitEntity.subscribe(eventData => {
    const { hitEntity, damagingEntity } = eventData;

    // Check if the entity that did the damage is a player
    if (damagingEntity && damagingEntity.typeId === 'minecraft:player') {
        const player = damagingEntity;
        const worldDimension = player.dimension;

        // Randomly choose between chicken and sheep
        const entityType = Math.random() < 0.5 ? EntityTypes.get('minecraft:chicken') : EntityTypes.get('minecraft:sheep');
        const entityTypeId = entityType.id;

        // Spawn the chosen entity at the hit entity's location
        worldDimension.spawnEntity(entityTypeId, hitEntity.location);

        // Send a message to the player (optional)
        player.sendMessage(`Spawned a ${entityTypeId}!`);
    }
});

import { world, ItemStack, EffectTypes } from '@minecraft/server';
import { ActionFormData } from '@minecraft/server-ui';

world.afterEvents.itemUse.subscribe(async (eventData) => {
  const { source: player, itemStack } = eventData;

  if (!itemStack || itemStack.typeId !== 'minecraft:nether_star') {
    return; 
  }

    if (itemStack.amount > 1) {
        itemStack.amount -= 1;
    }

  try {
    const form = new ActionFormData()
      .title("Nether Star Power")
      .body("Choose a power-up!")
      .button("Give me Speed!", "textures/items/apple")
      .button("Give me Strength!", "textures/items/apple_golden")
      .button("Give me Diamonds!", "textures/items/diamond"); 

    const result = await form.show(player);

    if (result.canceled) {
      player.sendMessage("Form closed.");
      return;
    }

    switch (result.selection) {
      case 0: 
        player.addEffect(EffectTypes.get("speed"), 200, { amplifier: 2 });
        player.sendMessage("You feel speedy!");
        break;
      case 1: 
        player.addEffect(EffectTypes.get("strength"), 200, { amplifier: 1 });
        player.sendMessage("You feel stronger!");
        break;
      case 2: 
        const randomAmount = Math.floor(Math.random() * 31) + 20; 
        
        // UPDATED HERE
        try {
            player.runCommand(`give @s diamond ${randomAmount}`);
            player.sendMessage(`You received ${randomAmount} diamonds!`);
        } catch (e) {
            console.warn("Command failed: " + e);
        }
        break;
    }
  } catch (error) {
    console.warn(`Error showing form: ${error} - ${error.stack}`);
  }
});

import { world, EntityTypes, ItemStack, system } from '@minecraft/server';
import { ActionFormData } from '@minecraft/server-ui';

import { world, EntityTypes, ItemStack, system } from '@minecraft/server';
import { ActionFormData } from '@minecraft/server-ui';

world.afterEvents.itemUse.subscribe(async (eventData) => {
    const { source: player, itemStack } = eventData;

    if (itemStack && itemStack.typeId === 'minecraft:anvil') {
        if (itemStack.amount > 1) {
            itemStack.amount -= 1;
        } else {
            player.getComponent("inventory").container.setItem(player.selectedSlot, undefined);
        }

        try {
            const form = new ActionFormData()
                .title("Anvil of Chance")
                .body("Press the button to test your luck!")
                .button("Random", "textures/items/apple");

            const result = await form.show(player);

            if (result.canceled) {
                player.sendMessage("§cForm closed.");
                return;
            }

            if (result.selection === 0) {
                system.runTimeout(() => {
                    let actionSelector = Math.random();

                    if (actionSelector < 0.4) {
                        let spawnedMobs = 0;
                        const numMobsToSpawn = Math.floor(Math.random() * 3) + 1; 
                        for (let i = 0; i < numMobsToSpawn; i++) {
                            const allEntityTypes = Array.from(EntityTypes.getAll());
                            const randomEntityType = allEntityTypes[Math.floor(Math.random() * allEntityTypes.length)];

                            try {
                                player.dimension.spawnEntity(randomEntityType.id, player.location);
                                spawnedMobs++;
                            } catch (error) {
                                console.warn(`§cError spawning entity ${randomEntityType.id}: ${error}`);
                            }
                        }
                        if (spawnedMobs > 0) {
                             player.sendMessage(`§aYou spawned ${spawnedMobs} creature(s)!`);
                        }  else {
                            player.sendMessage("§aNothing happened with spawning.");
                        }

                    } else if (actionSelector < 0.6) {
                        giveRandomDiamonds(player);

                    } else if (actionSelector < 0.75) {
                        const inventory = player.getComponent('inventory').container;
                        for (let i = 0; i < inventory.size; i++) {
                            inventory.setItem(i, undefined);
                        }
                        player.sendMessage("§aYour inventory has been cleared!");

                    } else if (actionSelector < 0.9) {
                        removeRandomItem(player);

                    } else {
                        player.sendMessage("§aNothing happened.");
                    }

                }, 24);
            }
        } catch (error) {
            console.warn(`§cError showing form: ${error}`);
        }
    }
});

function giveRandomDiamonds(player) {
    const randomAmount = Math.floor(Math.random() * 41) + 10;
    // UPDATED HERE
    try {
        player.runCommand(`give @s diamond ${randomAmount}`);
        player.sendMessage(`§aYou received ${randomAmount} diamonds!`);
    } catch (e) {
        console.warn("Command failed: " + e);
    }
}

function removeRandomItem(player) {
    const inventory = player.getComponent('inventory').container;
    let itemRemoved = false;

    for (let attempts = 0; attempts < 10; attempts++) {
        const randomSlot = Math.floor(Math.random() * inventory.size);
        const item = inventory.getItem(randomSlot);
        if (item) {
            inventory.setItem(randomSlot, undefined);
            player.sendMessage(`§aA random ${item.typeId} was removed from your inventory.`);
            itemRemoved = true;
            break; 
        }
    }

    if (!itemRemoved) {
        player.sendMessage("§aYour inventory was empty!");
    }
}

import { world, EffectTypes } from '@minecraft/server';

world.afterEvents.entityHitEntity.subscribe(eventData => {
    const { damagingEntity, hitEntity } = eventData;

    // Check if the damaging entity is a player
    if (damagingEntity && damagingEntity.typeId === 'minecraft:player') {
        const player = damagingEntity;

        // Get the player's selected slot index
        const selectedSlotIndex = player.selectedSlotIndex;

        // Get the item in the selected slot
        const selectedItem = player.getComponent('inventory').container.getItem(selectedSlotIndex);

        // Check if the selected item exists and is an iron sword
        if (selectedItem && selectedItem.typeId === 'minecraft:iron_sword') {
            //Check if the item has a name and if that name is "yes"
            if(selectedItem.nameTag === "yes"){
                player.addEffect(EffectTypes.get("strength"), 60, { amplifier: 1 });
            }
        }
    }
});

import { world, ItemStack, system } from '@minecraft/server';

world.beforeEvents.chatSend.subscribe((chatEvent) => {
    const sender = chatEvent.sender;
    const message = chatEvent.message;

    if (message.toLowerCase() === 'a') {
        chatEvent.cancel = true;

        const selectedSlotIndex = sender.selectedSlotIndex;

        if (selectedSlotIndex === -1) {
            sender.sendMessage("You must be holding an item to set lore.");
            return;
        }

        system.run(() => {
            try {
                const inventory = sender.getComponent('inventory').container;
                const selectedItem = inventory.getItem(selectedSlotIndex);

                if (!selectedItem) {
                    sender.sendMessage('No item selected!');
                    return;
                }

                console.warn(`Attempting to set lore on item: ${selectedItem.typeId}`);
                const newItem = new ItemStack(selectedItem.typeId, selectedItem.amount);

                // Attempt to copy data (optional)
                try { newItem.setCanPlaceOn(selectedItem.getCanPlaceOn()); } catch (error) {}
                try { newItem.setCanDestroy(selectedItem.getCanDestroy()); } catch (error) {}

                const lore = newItem.getLore() || [];
                lore.push("§6Blazed"); // Set the lore to "Blazed"

                try {
                    newItem.setLore(lore);
                } catch (e) {
                    sender.sendMessage(`This item (${selectedItem.typeId}) might not support lore. Item updated without new lore.`);
                    console.warn(`Failed to set lore on item: ${selectedItem.typeId}. Error: ${e}`);
                }

                inventory.setItem(selectedSlotIndex, newItem);

                if (newItem.getLore()?.includes("Blazed")) { // Check if "Blazed" is in the lore
                    sender.sendMessage('Item lore updated!');
                }

            } catch (error) {
                sender.sendMessage(`An error occurred: ${error}`);
                console.error(`Unexpected error: ${error}`);
            }
        });
    }
});

import { world, ItemStack, EntityTypes } from '@minecraft/server';

// Function to add "Static" lore to a sword
function addStaticLore(itemStack) {
    if (itemStack && itemStack.typeId.includes('sword')) {
        const lore = itemStack.getLore() || [];
        if (!lore.includes("§bStatic")) {
            lore.push("§bStatic");
            itemStack.setLore(lore);
            return true;
        } else {
            return false; // Lore already present
        }
    }
    return false; // Not a sword
}

world.afterEvents.itemUse.subscribe(eventData => {
    const { source: player, itemStack } = eventData;

    if (itemStack && itemStack.typeId === 'minecraft:nether_star') {
        const inventory = player.getComponent('inventory').container;
        let swordFound = false;

        for (let i = 0; i < 9; i++) {
            const hotbarItem = inventory.getItem(i);
            if (hotbarItem) {
                if (addStaticLore(hotbarItem)) {
                    player.sendMessage("§aStatic applied to sword!");
                    inventory.setItem(i, hotbarItem); // Update the inventory directly
                    swordFound = true;

                    if (itemStack.amount > 1) {
                        itemStack.amount -= 1;
                    } else {
                        inventory.setItem(player.selectedSlot, undefined);
                    }

                    break; // Exit loop after enchanting one sword
                }
            }
        }

        if (!swordFound) {
            player.sendMessage("§cNo sword found in your hotbar to apply Static.");
        }
    }
});

world.afterEvents.entityHitEntity.subscribe(eventData => {
    const { damagingEntity, hitEntity } = eventData;

    if (damagingEntity && damagingEntity.typeId === 'minecraft:player') {
        const player = damagingEntity;
        const selectedSlotIndex = player.selectedSlotIndex;
        const selectedItem = player.getComponent('inventory').container.getItem(selectedSlotIndex);

        if (selectedItem && selectedItem.typeId.includes('sword') && selectedItem.getLore()?.includes("§bStatic")) {
            hitEntity.dimension.spawnEntity("minecraft:lightning_bolt", hitEntity.location); // Corrected entity type
        }
    }
});

import { world, EffectTypes, ItemStack } from '@minecraft/server';

world.afterEvents.entityHitEntity.subscribe(eventData => {
    const { damagingEntity, hitEntity } = eventData;

    // Check if the damaging entity is a player
    if (damagingEntity && damagingEntity.typeId === 'minecraft:player') {
        const player = damagingEntity;

        // Get the player's selected slot index
        const selectedSlotIndex = player.selectedSlotIndex;

        // Get the item in the selected slot
        const selectedItem = player.getComponent('inventory').container.getItem(selectedSlotIndex);

        // Check if the selected item exists and is an iron sword
        if (selectedItem && selectedItem.typeId === 'minecraft:iron_sword') {
            //Check if the item has a name and if that name is "Blazing Strike"
            if(selectedItem.nameTag === "Blazing Strike"){
                // Set the target on fire for 5 seconds
                hitEntity.setOnFire(5, true);

                 // Spawn some flame particles at the hit entity's location (visual effect)
                  hitEntity.dimension.spawnParticle("minecraft:basic_flame_particle", hitEntity.location);

                // Calculate direction vector for knockback
                const direction = {
                    x: hitEntity.location.x - player.location.x,
                    y: hitEntity.location.y - player.location.y,
                    z: hitEntity.location.z - player.location.z,
                  };

                // Normalize the direction vector
                const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
                const normalizedDirection = {
                  x: direction.x / magnitude,
                  y: direction.y / magnitude,
                  z: direction.z / magnitude,
                };

                // Apply knockback impulse
                hitEntity.applyImpulse(
                  {
                    x: normalizedDirection.x * 0.5,
                    y: normalizedDirection.y * 0.25, // Reduced vertical knockback
                    z: normalizedDirection.z * 0.5
                  }
                );

                  // Play a fire sound (optional)
                  hitEntity.dimension.playSound("fire.ignite", hitEntity.location);
            }
        }
    }
});

world.beforeEvents.chatSend.subscribe((chatEvent) => {
  const sender = chatEvent.sender;
  const message = chatEvent.message;

  if (message.toLowerCase() === 'blaze') {
      chatEvent.cancel = true;

      const selectedSlotIndex = sender.selectedSlotIndex;

      if (selectedSlotIndex === -1) {
          sender.sendMessage("You must be holding an item to set enchant.");
          return;
      }

      try {
          const inventory = sender.getComponent('inventory').container;
          const selectedItem = inventory.getItem(selectedSlotIndex);

          if (!selectedItem) {
              sender.sendMessage('No item selected!');
              return;
          }

          console.warn(`Attempting to set enchant on item: ${selectedItem.typeId}`);
          const newItem = new ItemStack(selectedItem.typeId, selectedItem.amount);

          // Attempt to copy data (optional)
          try { newItem.setCanPlaceOn(selectedItem.getCanPlaceOn()); } catch (error) {}
          try { newItem.setCanDestroy(selectedItem.getCanDestroy()); } catch (error) {}

          try {
              newItem.nameTag = "Blazing Strike";
          } catch (e) {
              sender.sendMessage(`This item (${selectedItem.typeId}) might not support name tags. Item updated without enchant.`);
              console.warn(`Failed to set enchant on item: ${selectedItem.typeId}. Error: ${e}`);
              return;
          }

          inventory.setItem(selectedSlotIndex, newItem);
          if (newItem.nameTag === "Blazing Strike")
            sender.sendMessage('Item enchant updated!');

      } catch (error) {
          sender.sendMessage(`An error occurred: ${error}`);
          console.error(`Unexpected error: ${error}`);
      }
  }
});

import { world, ItemStack } from '@minecraft/server';

// Function to add "Chunk" lore to a pickaxe
function addChunkLore(itemStack) {
    if (itemStack && itemStack.typeId.includes('pickaxe')) {
        const lore = itemStack.getLore() || [];
        if (!lore.includes("§eChunk")) {
            lore.push("§eChunk");
            itemStack.setLore(lore);
            return true; // Lore added
        } else {
            return false; // Lore already present
        }
    }
    return false; // Not a pickaxe
}

world.afterEvents.itemUse.subscribe(eventData => {
    const { source: player, itemStack } = eventData;

    if (itemStack && itemStack.typeId === 'minecraft:nether_star') {
        const inventory = player.getComponent('inventory').container;
        let pickaxeFound = false;

        for (let i = 0; i < 9; i++) {
            const hotbarItem = inventory.getItem(i);
            if (hotbarItem) {
                if (addChunkLore(hotbarItem)) {
                    player.sendMessage("§aChunk applied to pickaxe!");
                    inventory.setItem(i, hotbarItem); // Update inventory
                    pickaxeFound = true;

                    if (itemStack.amount > 1) {
                        itemStack.amount -= 1;
                    } else {
                        inventory.setItem(player.selectedSlot, undefined);
                    }
                    break; // Stop after one pickaxe
                }
            }
        }

        if (!pickaxeFound) {
            player.sendMessage("§cNo pickaxe found in your hotbar to apply Chunk.");
        }
    }
});

function getOreDrop(block) {
    switch (block.typeId) {
        case "minecraft:ancient_debris": return "minecraft:ancient_debris";
        case "minecraft:iron_ore": return "minecraft:raw_iron";
        case "minecraft:gold_ore": return "minecraft:raw_gold";
        case "minecraft:diamond_ore": return "minecraft:diamond";
        case "minecraft:coal_ore": return "minecraft:coal";
        case "minecraft:emerald_ore": return "minecraft:emerald";
        case "minecraft:lapis_ore": return "minecraft:lapis_lazuli";
        case "minecraft:copper_ore": return "minecraft:raw_copper";
        case "minecraft:redstone_ore": return "minecraft:redstone";
        case "minecraft:nether_gold_ore": return "minecraft:gold_ingot";
        case "minecraft:nether_quartz_ore": return "minecraft:nether_quartz";
        case "minecraft:deepslate_iron_ore": return "minecraft:raw_iron";
        case "minecraft:deepslate_gold_ore": return "minecraft:raw_gold";
        case "minecraft:deepslate_diamond_ore": return "minecraft:diamond";
        case "minecraft:deepslate_coal_ore": return "minecraft:coal";
        case "minecraft:deepslate_emerald_ore": return "minecraft:emerald";
        case "minecraft:deepslate_lapis_ore": return "minecraft:lapis_lazuli";
        case "minecraft:deepslate_copper_ore": return "minecraft:raw_copper";
        case "minecraft:deepslate_redstone_ore": return "minecraft:redstone";
        default: return block.typeId;
    }
}

world.afterEvents.playerBreakBlock.subscribe(eventData => {
    const { player, block } = eventData;
    const selectedItem = player.getComponent('inventory').container.getItem(player.selectedSlotIndex);

    if (selectedItem && selectedItem.typeId.includes('pickaxe') && selectedItem.getLore()?.includes("§eChunk")) {
        const x = block.x;
        const y = block.y;
        const z = block.z;
        const dimension = player.dimension;

         const unbreakableBlocks = ["minecraft:bedrock", "minecraft:lava", "minecraft:flowing_lava", "minecraft:water", "minecraft:flowing_water", "minecraft:end_portal_frame", "minecraft:end_gateway", "minecraft:end_portal", "minecraft:portal", "minecraft:piston_arm_collision", "minecraft:sticky_piston_arm_collision", "minecraft:moving_block", "minecraft:mob_spawner", "minecraft:vault", "minecraft:trial_spawner"]; // Example

        // Store the original block's data before it's broken
        const originalBlockTypeId = block.typeId;

        let originalBlockItemStack;
        try {
            originalBlockItemStack = new ItemStack(getOreDrop(block), 1, block.permutation.getState('block_damage'));
        } catch (e) {
            console.warn(`Block: ${originalBlockTypeId} does not have block_damage state. Creating ItemStack without it. Error: ${e}`);
            originalBlockItemStack = new ItemStack(getOreDrop(block), 1);
        }



        for (let offsetX = -1; offsetX <= 1; offsetX++) {
            for (let offsetY = -1; offsetY <= 1; offsetY++) {
                for (let offsetZ = -1; offsetZ <= 2; offsetZ++) {
                    if (offsetX === 0 && offsetY === 0 && offsetZ === 0) continue; // Skip initial block

                    const targetBlock = dimension.getBlock({ x: x + offsetX, y: y + offsetY, z: z + offsetZ });

                    if (targetBlock && !unbreakableBlocks.includes(targetBlock.typeId) && targetBlock.typeId !== "minecraft:air") {
                        const dropTypeId = getOreDrop(targetBlock);
                        let itemStack;

                        try {
                           itemStack = new ItemStack(dropTypeId, 1, targetBlock.permutation.getState('block_damage'));
                        } catch (e) {
                           console.warn(`Block: ${targetBlock.typeId} does not have block_damage state. Creating ItemStack without it. Error: ${e}`);
                           itemStack = new ItemStack(dropTypeId, 1);
                        }

                        try {
                            dimension.spawnItem(itemStack, targetBlock.location);
                            targetBlock.setType("minecraft:air");
                        } catch (error) {
                           if(targetBlock.typeId !== "minecraft:air"){
                                player.sendMessage(`§cCould not mine or spawn item for: ${targetBlock.typeId}. It might be unbreakable or doesn't have a corresponding item.`);
                           }
                           console.warn(`Could not spawn item for block: ${targetBlock.typeId}. Error: ${error}`);
                        }

                    }
                }
            }
        }

                try {
                    dimension.spawnItem(originalBlockItemStack, block.location);
                } catch (error) {
                    if (originalBlockTypeId !== "minecraft:air") {
                        player.sendMessage(`§cCould not mine: ${originalBlockTypeId}. It might be unbreakable or doesn't drop an item.`);
                    }
                    console.warn(`Could not mine or spawn item for block: ${originalBlockTypeId}. Error: ${error}`);
                }
    }
});

import { world, ItemStack, system } from '@minecraft/server';

// Function to add "Prosperity" lore to a pickaxe
function addProsperityLore(itemStack) {
    if (itemStack && itemStack.typeId.includes('pickaxe')) {
        const lore = itemStack.getLore() || [];
        if (!lore.includes("§Catalyst")) {
            lore.push("§dCatalyst");
            try {
                itemStack.setLore(lore);
                return true;
            } catch (error) {
                console.error(`Error applying lore: ${error}`);
                return false;
            }
        }
    }
    return false;
}

world.afterEvents.itemUse.subscribe(eventData => {
    const { source: player, itemStack } = eventData;
    if (!player || !itemStack) {
        console.warn("Invalid player or itemStack encountered in itemUse event.");
        return;
    }

    if (itemStack.typeId === 'minecraft:nether_star') {
        const inventory = player.getComponent('inventory').container;
        let pickaxeFound = false;

        for (let i = 0; i < 9; i++) {
            const hotbarItem = inventory.getItem(i);
            if (hotbarItem) {
                if (addProsperityLore(hotbarItem)) {
                    player.sendMessage("§dCatalyst applied to pickaxe!");
                    inventory.setItem(i, hotbarItem);
                    pickaxeFound = true;

                    if (itemStack.amount > 1) {
                        itemStack.amount -= 1;
                    } else {
                        inventory.setItem(player.selectedSlot, undefined);
                    }
                    break;
                }
            }
        }

        if (!pickaxeFound) {
            player.sendMessage("§cNo pickaxe found in your hotbar to apply Prosperity.");
        }
    }
});

// Block Drop Map (add more as needed)
const blockDropMap = {
    'minecraft:coal_ore': 'minecraft:coal',
    'minecraft:deepslate_coal_ore': 'minecraft:coal',
    'minecraft:iron_ore': 'minecraft:raw_iron',
    'minecraft:deepslate_iron_ore': 'minecraft:raw_iron',
    'minecraft:gold_ore': 'minecraft:raw_gold',
    'minecraft:deepslate_gold_ore': 'minecraft:raw_gold',
    'minecraft:copper_ore': 'minecraft:raw_copper',
    'minecraft:deepslate_copper_ore': 'minecraft:raw_copper',
    'minecraft:lapis_ore': 'minecraft:lapis_lazuli',
    'minecraft:deepslate_lapis_ore': 'minecraft:lapis_lazuli',
    'minecraft:diamond_ore': 'minecraft:diamond',
    'minecraft:deepslate_diamond_ore': 'minecraft:diamond',
    'minecraft:emerald_ore': 'minecraft:emerald',
    'minecraft:deepslate_emerald_ore': 'minecraft:emerald',
    'minecraft:nether_gold_ore': 'minecraft:gold_nugget',
    'minecraft:nether_quartz_ore': 'minecraft:quartz',
    'minecraft:redstone_ore': 'minecraft:redstone',
    'minecraft:deepslate_redstone_ore': 'minecraft:redstone',
    'minecraft:ancient_debris': 'minecraft:ancient_debris',
};

world.afterEvents.playerBreakBlock.subscribe(eventData => {
    const { player, block, brokenBlockPermutation } = eventData;
    const selectedItem = player.getComponent('inventory').container.getItem(player.selectedSlotIndex);

    if (!player || !brokenBlockPermutation || !selectedItem) return;

    if (selectedItem.typeId.includes('pickaxe') && selectedItem.getLore()?.includes("§dCatalyst")) {
        const originalBlockType = brokenBlockPermutation.type.id;

        if (blockDropMap.hasOwnProperty(originalBlockType)) {
            const dimension = player.dimension;

            try {
                const dropTypeId = blockDropMap[originalBlockType];
                let originalBlockDrop;

                try {
                    originalBlockDrop = new ItemStack(dropTypeId, 1, brokenBlockPermutation.getState("block_damage"));
                } catch (error) {
                    console.warn(`Error getting block_damage for ${originalBlockType}: ${error}. Creating ItemStack without data.`);
                    originalBlockDrop = new ItemStack(dropTypeId, 1);
                }

                const doubledDrop = new ItemStack(originalBlockDrop.typeId, 1);

                system.runTimeout(() => {  // Introduce delay
                    try {
                        dimension.spawnItem(doubledDrop, block.location);
                    } catch (error) {
                        console.error(`Could not spawn doubled drop for ${originalBlockType}: ${error}`);
                        player.sendMessage(`§cError spawning doubled drop for ${originalBlockType}`);
                    }
                }, 4); // 2 ticks delay (adjust as needed)

            } catch (error) {
                console.error(`Could not double drop for ${originalBlockType}: ${error}`);
                player.sendMessage(`§cError doubling drop for ${originalBlockType}`);
            }
        }
    }
});

import { world } from '@minecraft/server';

world.afterEvents.entityHitEntity.subscribe(eventData => {
    const { damagingEntity, hitEntity } = eventData;

    if (damagingEntity && damagingEntity.typeId === 'minecraft:player') {
        const player = damagingEntity;

        const hitEntityViewDirection = hitEntity.getViewDirection();
        const hitEntityLocation = hitEntity.location;

        const offsetDistance = 2;
        const offsetX = -hitEntityViewDirection.x * offsetDistance;
        const offsetZ = -hitEntityViewDirection.z * offsetDistance;

        const newLocation = {
            x: hitEntityLocation.x + offsetX,
            y: hitEntityLocation.y,
            z: hitEntityLocation.z + offsetZ
        };

        player.teleport(newLocation, {
            dimension: hitEntity.dimension
        });

        const oppositeDirection = {
            x: -hitEntityViewDirection.x,
            y: -hitEntityViewDirection.y,
            z: -hitEntityViewDirection.z
        };

        // UPDATED HERE
        try {
            player.runCommand(`tp @s ~ ~ ~ facing ${hitEntityLocation.x + oppositeDirection.x} ${hitEntityLocation.y + oppositeDirection.y} ${hitEntityLocation.z + oppositeDirection.z}`);
        } catch (e) {
            console.warn("TP Command failed: " + e);
        }
    }
});

import { world, ItemStack, system } from '@minecraft/server';

// Function to add "Collector" lore to a pickaxe
function addCollectorLore(itemStack) {
    if (itemStack && itemStack.typeId.includes('pickaxe')) {
        const lore = itemStack.getLore() || [];
        if (!lore.includes("§7Collector")) {
            lore.push("§7Collector");
            itemStack.setLore(lore);
            return true; // Lore added
        } else {
            return false; // Lore already present
        }
    }
    return false; // Not a pickaxe
}

world.afterEvents.itemUse.subscribe(eventData => {
    const { source: player, itemStack } = eventData;

    if (itemStack && itemStack.typeId === 'minecraft:nether_star') {
        const inventory = player.getComponent('inventory').container;
        let pickaxeFound = false;

        for (let i = 0; i < 9; i++) {
            const hotbarItem = inventory.getItem(i);
            if (hotbarItem) {
                if (addCollectorLore(hotbarItem)) {
                    player.sendMessage("§aCollector applied to pickaxe!");
                    inventory.setItem(i, hotbarItem); // Update inventory
                    pickaxeFound = true;

                    if (itemStack.amount > 1) {
                        itemStack.amount -= 1;
                    } else {
                        inventory.setItem(player.selectedSlot, undefined);
                    }
                    break; // Stop after one pickaxe
                }
            }
        }

        if (!pickaxeFound) {
            player.sendMessage("§cNo pickaxe found in your hotbar to apply Collector.");
        }
    }
});

world.afterEvents.playerBreakBlock.subscribe(eventData => {
    const { player, block } = eventData;
    const selectedItem = player.getComponent('inventory').container.getItem(player.selectedSlotIndex);

    if (selectedItem && selectedItem.typeId.includes('pickaxe') && selectedItem.getLore()?.includes("§7Collector")) {
        const dimension = player.dimension;
        const blockLocation = block.location;

        system.runTimeout(() => {
            try {
                const randomNumber = Math.random();
                let itemToSpawn;

                if (randomNumber < 0.33) {
                    itemToSpawn = new ItemStack("minecraft:diamond", 1);
                } else if (randomNumber < 0.66) {
                    itemToSpawn = new ItemStack("minecraft:netherite_scrap", 1);
                } else {
                    itemToSpawn = new ItemStack("minecraft:cobblestone", 1);
                }

                dimension.spawnItem(itemToSpawn, blockLocation);

            } catch (error) {
                console.warn(`Could not spawn item at ${blockLocation}: ${error}`);
                player.sendMessage("§cCould not spawn item.");
            }
        }, 5); // 5 tick delay
    }
});

// Grapple Hook Script (V32 - Teleport Reel, No Sound - Final Working Version)
console.warn("[Grapple V32 Final NoSound] Script file parsing started.");

import { world, system, Player, Entity } from '@minecraft/server';

console.warn("[Grapple V32 Final NoSound] Imports successful.");

// --- Configuration ---
const REEL_SPEED = 1.0; // Adjust for smoothness (e.g., 0.8, 1.0, 1.2)
const MAX_REEL_STEPS = 50; // Adjust if reel feels too short/long for the speed
const TARGET_Y_OFFSET = 0.5; // Height offset for target location
const MAX_DISTANCE = 64; // Max distance grapple works / player search
// ---------------------

const reelingPlayers = new Set(); // Tracks players currently being reeled

// --- Recursive Reel Function ---
function doReelStep(player, targetLocation, stepsLeft, speed) {
    // Stop conditions
    if (stepsLeft <= 0) { reelingPlayers.delete(player.id); return; }
    if (!player || !player.location || !player.dimension || !player.id) { if (player && player.id) reelingPlayers.delete(player.id); return; }
    if (!reelingPlayers.has(player.id)) { return; }

    const currentPos = player.location;
    const vectorToTarget = { x: targetLocation.x - currentPos.x, y: targetLocation.y - currentPos.y, z: targetLocation.z - currentPos.z };
    const distanceToTarget = Math.sqrt(vectorToTarget.x**2 + vectorToTarget.y**2 + vectorToTarget.z**2);

    // Check if target reached
    if (distanceToTarget <= speed) {
        try { player.teleport(targetLocation, { dimension: player.dimension }); } catch (e) { console.error(`[Grapple V32 Final] Error teleporting player ${player.name} to final target: ${e}`); }
        reelingPlayers.delete(player.id);
        return;
    }

    // Calculate next step and teleport
    const normalizedDirection = { x: vectorToTarget.x / distanceToTarget, y: vectorToTarget.y / distanceToTarget, z: vectorToTarget.z / distanceToTarget };
    const nextPos = { x: currentPos.x + normalizedDirection.x * speed, y: currentPos.y + normalizedDirection.y * speed, z: currentPos.z + normalizedDirection.z * speed };
    try {
        player.teleport(nextPos, { dimension: player.dimension, facingLocation: targetLocation });
    } catch (teleportError) {
        console.error(`[Grapple V32 Final] Error teleporting player ${player.name} during reel step: ${teleportError}`);
        reelingPlayers.delete(player.id);
        return;
    }

    // Schedule next step
    system.runTimeout(() => {
        doReelStep(player, targetLocation, stepsLeft - 1, speed);
    }, 1);
}

// --- Event Subscription: Entity Remove ---
try {
    world.beforeEvents.entityRemove.subscribe(event => {
        const { removedEntity } = event;

        if (removedEntity.typeId === 'minecraft:fishing_hook') {
            const hookLocation = removedEntity.location;
            if (!hookLocation) return;

            // Find nearby player holding rod
            let potentialPlayers = [];
            const queryOptions = { location: hookLocation, maxDistance: MAX_DISTANCE, type: 'minecraft:player' };
            try {
                const nearbyPlayers = removedEntity.dimension.getEntities(queryOptions);
                for (const player of nearbyPlayers) {
                    if (player instanceof Player) {
                        const inventory = player.getComponent('inventory')?.container;
                        if (!inventory) continue;
                        const selectedSlot = player.selectedSlotIndex;
                        const heldItem = inventory.getItem(selectedSlot);
                        if (heldItem && heldItem.typeId === 'minecraft:fishing_rod') {
                            potentialPlayers.push(player);
                        }
                    }
                }
            } catch (error) {
                console.error(`[Grapple V32 Final] Error during nearby player loop: ${error}`);
                return;
            }

            // Initiate reel if unique player found
            if (potentialPlayers.length === 1) {
                const targetPlayer = potentialPlayers[0];
                if (reelingPlayers.has(targetPlayer.id)) return; // Already reeling

                console.warn(`[Grapple V32 Final] Initiating teleport reel-in for ${targetPlayer.name}.`);
                reelingPlayers.add(targetPlayer.id);
                const targetLoc = { x: hookLocation.x, y: hookLocation.y + TARGET_Y_OFFSET, z: hookLocation.z };
                system.runTimeout(() => { // Start the reel process
                    doReelStep(targetPlayer, targetLoc, MAX_REEL_STEPS, REEL_SPEED);
                }, 1);
                // Sound attempt removed
            } else if (potentialPlayers.length > 1) {
                console.warn(`[Grapple V32 Final] Found ${potentialPlayers.length} nearby players holding fishing rods. Cannot initiate reel-in.`);
            }
        }
    });
    console.warn("[Grapple V32 Final NoSound] Subscribed to entityRemove successfully.");
} catch (e) {
    console.error(`[Grapple V32 Final NoSound] FAILED to subscribe to entityRemove: ${e} - ${e.stack}`);
}

// Cleanup on player leave
world.afterEvents.playerLeave.subscribe(event => {
    if (reelingPlayers.has(event.playerId)) {
        reelingPlayers.delete(event.playerId);
    }
});

console.warn("[Grapple V32 Final NoSound] Script file fully parsed and setup complete.");

import { world, system, BlockPermutation, EntityTypes } from '@minecraft/server';

// --- Configuration ---
const SCRIPT_VERSION = "V9.0";
const STONE_TRIGGER_ID = 'minecraft:stone';
const GLASS_TRIGGER_ID = 'minecraft:glass';
const WALL_BLOCK_ID = 'minecraft:stone_bricks';
const PATH_BLOCK_ID = 'minecraft:air';
const SOLUTION_BLOCK_ID = 'minecraft:white_concrete'; // Final path (below)
const EXPLORE_BLOCK_ID = 'minecraft:yellow_concrete'; // Exploration viz (below)
const BACKTRACK_BLOCK_ID = 'minecraft:gray_concrete';   // Backtrack viz (below)
const GLASS_FLOOR_BLOCK_ID = 'minecraft:black_concrete'; // Floor for glass maze
const MAZE_WIDTH_BLOCKS = 41;
const MAZE_HEIGHT_BLOCKS = 41;
const MAZE_WALL_HEIGHT = 3;
const BLOCKS_PER_TICK_BUILD = 250; // Slightly faster build
const BLOCKS_PER_TICK_VIZ = 500; // Faster visualization
const ARMOR_STAND_NAME = "Maze Solver";
const ARMOR_STAND_TICKS_PER_STEP = 2;
const VISUALIZE_EXPLORATION = true;
// --- End Configuration ---

// --- Global Variables ---
let wallPerm, pathPerm, solutionPerm, explorePerm, backtrackPerm, glassFloorPerm;
let permutationsReady = false; // Flag to check if initialization succeeded
const MAZE_CELL_WIDTH = Math.floor(MAZE_WIDTH_BLOCKS / 2);
const MAZE_CELL_HEIGHT = Math.floor(MAZE_HEIGHT_BLOCKS / 2);
const LOG_PREFIX = `[MazeGen ${SCRIPT_VERSION}]`;
// --- End Global Variables ---

// --- Utility Functions ---
function log(message) { console.log(`${LOG_PREFIX} ${message}`); }
function warn(message) { console.warn(`${LOG_PREFIX} ${message}`); }
function error(message, err = null) { console.error(`${LOG_PREFIX} ${message}${err ? `: ${err} - ${err.stack}` : ''}`); }

// --- Initialize Permutations ---
system.run(() => {
    try {
        log("Initializing permutations...");
        wallPerm = BlockPermutation.resolve(WALL_BLOCK_ID);
        pathPerm = BlockPermutation.resolve(PATH_BLOCK_ID);
        solutionPerm = BlockPermutation.resolve(SOLUTION_BLOCK_ID);
        explorePerm = BlockPermutation.resolve(EXPLORE_BLOCK_ID);
        backtrackPerm = BlockPermutation.resolve(BACKTRACK_BLOCK_ID);
        glassFloorPerm = BlockPermutation.resolve(GLASS_FLOOR_BLOCK_ID);

        if (!wallPerm || !pathPerm || !solutionPerm || !explorePerm || !backtrackPerm || !glassFloorPerm) {
             throw new Error("One or more block permutations failed to resolve!");
        }
        permutationsReady = true;
        log("Permutations initialized successfully.");
    } catch (err) {
        error("CRITICAL ERROR initializing permutations", err);
        world.sendMessage("§c[MazeGen] CRITICAL ERROR: Failed to initialize block types. Maze generation disabled.");
    }
});
// --- End Initialization ---

// --- Maze Generation Function (Wilson's Algorithm) ---
function generateMazeGrid_Wilsons() {
    log(`Generating ${MAZE_CELL_WIDTH}x${MAZE_CELL_HEIGHT} cell grid using Wilson's...`);
    const grid = Array(MAZE_HEIGHT_BLOCKS).fill(0).map(() => Array(MAZE_WIDTH_BLOCKS).fill(0));
    const inMaze = Array(MAZE_CELL_HEIGHT).fill(false).map(() => Array(MAZE_CELL_WIDTH).fill(false));
    const unvisited = [];
    for (let r = 0; r < MAZE_CELL_HEIGHT; r++) { for (let c = 0; c < MAZE_CELL_WIDTH; c++) { unvisited.push({ r, c }); } }
    const isCellValid = (r, c) => r >= 0 && r < MAZE_CELL_HEIGHT && c >= 0 && c < MAZE_CELL_WIDTH;
    if (unvisited.length === 0) return grid; // Handle edge case of 0 size

    const initialIndex = Math.floor(Math.random() * unvisited.length);
    const initialCell = unvisited.splice(initialIndex, 1)[0];
    inMaze[initialCell.r][initialCell.c] = true;
    grid[initialCell.r * 2 + 1][initialCell.c * 2 + 1] = 1;

    let iterations = 0;
    const maxIterations = MAZE_CELL_WIDTH * MAZE_CELL_HEIGHT * 10; // Safety break

    while (unvisited.length > 0 && iterations < maxIterations) {
        iterations++;
        const startIndex = Math.floor(Math.random() * unvisited.length);
        const startCell = unvisited[startIndex];
        let currentWalkPath = [startCell];
        let walkVisited = { [`${startCell.r},${startCell.c}`]: 0 };

        let walkIterations = 0;
        const maxWalkIterations = MAZE_WIDTH_BLOCKS * MAZE_HEIGHT_BLOCKS * 2; // Safety break for walk

        while (walkIterations < maxWalkIterations) {
            walkIterations++;
            const currentCell = currentWalkPath[currentWalkPath.length - 1];
            const neighbors = [];
            if (isCellValid(currentCell.r - 1, currentCell.c)) neighbors.push({ r: currentCell.r - 1, c: currentCell.c });
            if (isCellValid(currentCell.r + 1, currentCell.c)) neighbors.push({ r: currentCell.r + 1, c: currentCell.c });
            if (isCellValid(currentCell.r, currentCell.c - 1)) neighbors.push({ r: currentCell.r, c: currentCell.c - 1 });
            if (isCellValid(currentCell.r, currentCell.c + 1)) neighbors.push({ r: currentCell.r, c: currentCell.c + 1 });

            if (neighbors.length === 0) { // Should not happen in a grid but safety first
                 warn("Walk reached dead end unexpectedly.");
                 break;
            }

            const nextCell = neighbors[Math.floor(Math.random() * neighbors.length)];
            const nextCellKey = `${nextCell.r},${nextCell.c}`;

            if (walkVisited.hasOwnProperty(nextCellKey)) {
                const loopStartIndex = walkVisited[nextCellKey];
                const cellsToUntrack = currentWalkPath.splice(loopStartIndex + 1);
                for(const cell of cellsToUntrack) { delete walkVisited[`${cell.r},${cell.c}`]; }
                // Don't re-add nextCell, it's already the last element after splice
            } else {
                currentWalkPath.push(nextCell);
                walkVisited[nextCellKey] = currentWalkPath.length - 1;
            }

            if (inMaze[nextCell.r][nextCell.c]) { break; } // Hit the main maze
        } // End walk loop

        if(walkIterations >= maxWalkIterations) {
             warn(`Walk exceeded max iterations for start cell ${startCell.r},${startCell.c}. Skipping path.`);
             // Optionally remove startCell from unvisited to prevent infinite loops if it's truly stuck
             const stuckIndex = unvisited.findIndex(uc => uc.r === startCell.r && uc.c === startCell.c);
             if (stuckIndex > -1) unvisited.splice(stuckIndex, 1);
             continue; // Try a different starting cell
        }

        // Add walk to maze
        for (let i = 0; i < currentWalkPath.length; i++) { // Iterate up to the last element
            const cell = currentWalkPath[i];
             if (!inMaze[cell.r][cell.c]) {
                 inMaze[cell.r][cell.c] = true;
                 const unvisitedIndex = unvisited.findIndex(uc => uc.r === cell.r && uc.c === cell.c);
                 if (unvisitedIndex > -1) unvisited.splice(unvisitedIndex, 1);
             }
             grid[cell.r * 2 + 1][cell.c * 2 + 1] = 1; // Carve cell

             // Carve wall to next cell in path (if not last cell)
             if (i < currentWalkPath.length - 1) {
                 const cell1 = currentWalkPath[i];
                 const cell2 = currentWalkPath[i+1];
                 if (cell2.r < cell1.r) grid[cell1.r * 2][cell1.c * 2 + 1] = 1;
                 else if (cell2.r > cell1.r) grid[cell2.r * 2][cell1.c * 2 + 1] = 1;
                 else if (cell2.c < cell1.c) grid[cell1.r * 2 + 1][cell1.c * 2] = 1;
                 else if (cell2.c > cell1.c) grid[cell1.r * 2 + 1][cell2.c * 2] = 1;
             }
        }
        // Log progress occasionally
        if (unvisited.length > 0 && unvisited.length % 100 === 0) {
             log(`Wilson's progress: ${unvisited.length} cells remaining...`);
        }
    } // End main loop

    if (iterations >= maxIterations) {
         warn("Wilson's algorithm exceeded max iterations. Maze might be incomplete.");
    }
    log("Wilson's grid generation complete.");
    return grid;
}

// --- Build Maze Function (Async Generator - Conditional Walls & Glass Floor - Refined) ---
function* buildMazeInWorld_Async(dimension, startLocation, grid, buildWalls, player) {
    if (!wallPerm || !pathPerm || !glassFloorPerm) { error("Build Cannot start: Perms not ready."); player.sendMessage("§c[MazeGen] Error: Build resources not ready."); return; }
    log(`Starting async build (Build Walls: ${buildWalls})...`);
    const startX = startLocation.x; const startY = startLocation.y; const startZ = startLocation.z;
    let blocksPlacedThisTick = 0; let totalBlocksPlaced = 0;
    const startTime = Date.now();

    for (let r = 0; r < MAZE_HEIGHT_BLOCKS; r++) {
        for (let c = 0; c < MAZE_WIDTH_BLOCKS; c++) {
            const isPath = grid[r]?.[c] === 1; // Safe navigation

            if (isPath) {
                // Place air for the full height
                for (let h = 0; h < MAZE_WALL_HEIGHT; h++) {
                    const blockLocation = { x: startX + c, y: startY + h, z: startZ + r };
                    try {
                        dimension.setBlockPermutation(blockLocation, pathPerm);
                        blocksPlacedThisTick++; totalBlocksPlaced++;
                        if (blocksPlacedThisTick >= BLOCKS_PER_TICK_BUILD) { yield; blocksPlacedThisTick = 0; }
                    } catch (err) { if (Math.random() < 0.01) { warn(`Async build error (path): ${err}`); } blocksPlacedThisTick++; totalBlocksPlaced++; if (blocksPlacedThisTick >= BLOCKS_PER_TICK_BUILD) { yield; blocksPlacedThisTick = 0; } }
                }
            } else { // It's a wall cell
                if (buildWalls) {
                    // Place walls for the full height
                    for (let h = 0; h < MAZE_WALL_HEIGHT; h++) {
                        const blockLocation = { x: startX + c, y: startY + h, z: startZ + r };
                        try {
                            dimension.setBlockPermutation(blockLocation, wallPerm);
                            blocksPlacedThisTick++; totalBlocksPlaced++;
                            if (blocksPlacedThisTick >= BLOCKS_PER_TICK_BUILD) { yield; blocksPlacedThisTick = 0; }
                        } catch (err) { if (Math.random() < 0.01) { warn(`Async build error (wall): ${err}`); } blocksPlacedThisTick++; totalBlocksPlaced++; if (blocksPlacedThisTick >= BLOCKS_PER_TICK_BUILD) { yield; blocksPlacedThisTick = 0; } }
                    }
                } else {
                    // No walls: Place black concrete floor at y-1, then air above
                    const floorLoc = { x: startX + c, y: startY - 1, z: startZ + r };
                    try {
                        dimension.setBlockPermutation(floorLoc, glassFloorPerm);
                        blocksPlacedThisTick++; totalBlocksPlaced++;
                        if (blocksPlacedThisTick >= BLOCKS_PER_TICK_BUILD) { yield; blocksPlacedThisTick = 0; }
                    } catch (err) { if (Math.random() < 0.01) { warn(`Async build error (glass floor): ${err}`); } blocksPlacedThisTick++; totalBlocksPlaced++; if (blocksPlacedThisTick >= BLOCKS_PER_TICK_BUILD) { yield; blocksPlacedThisTick = 0; } }

                    for (let h = 0; h < MAZE_WALL_HEIGHT; h++) {
                        const airLoc = { x: startX + c, y: startY + h, z: startZ + r };
                         try {
                            dimension.setBlockPermutation(airLoc, pathPerm); // Air above floor
                            blocksPlacedThisTick++; totalBlocksPlaced++;
                            if (blocksPlacedThisTick >= BLOCKS_PER_TICK_BUILD) { yield; blocksPlacedThisTick = 0; }
                        } catch (err) { if (Math.random() < 0.01) { warn(`Async build error (glass air): ${err}`); } blocksPlacedThisTick++; totalBlocksPlaced++; if (blocksPlacedThisTick >= BLOCKS_PER_TICK_BUILD) { yield; blocksPlacedThisTick = 0; } }
                    }
                }
            }
        } // End column loop
    } // End row loop
    const endTime = Date.now(); const duration = (endTime - startTime) / 1000;
    log(`Async maze build finished. Placed ~${totalBlocksPlaced} blocks in ${duration.toFixed(2)} seconds.`);
}


// --- Pathfinding Function (DFS - Finds LONGEST path) ---
function findLongestPathDFS(grid, startRC, exitRCs) {
    log(`Starting DFS from ${startRC.r},${startRC.c} to find LONGEST path to ${exitRCs.length} exits.`);
    const rows = grid.length; const cols = grid[0].length;
    const exitSet = new Set(exitRCs.map(e => `${e.r},${e.c}`));
    let longestPath = [];

    function dfsRecursive(current, path, visited) {
        const currentKey = `${current.r},${current.c}`;
        path.push(current); visited.add(currentKey);

        if (exitSet.has(currentKey)) {
            if (path.length > longestPath.length) {
                longestPath = [...path];
                // log(`Found new longest path to exit ${current.r},${current.c}. Length: ${longestPath.length}`); // Optional: Can be spammy
            }
        }

        const neighbors = [ { r: current.r - 1, c: current.c }, { r: current.r + 1, c: current.c }, { r: current.r, c: current.c - 1 }, { r: current.r, c: current.c + 1 } ];
        for (let i = neighbors.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [neighbors[i], neighbors[j]] = [neighbors[j], neighbors[i]]; }

        for (const n of neighbors) {
            const neighborKey = `${n.r},${n.c}`;
            if (n.r >= 0 && n.r < rows && n.c >= 0 && n.c < cols &&
                grid[n.r]?.[n.c] === 1 && !visited.has(neighborKey)) { // Safe navigation on grid access
                dfsRecursive(n, path, visited);
            }
        }
        path.pop(); visited.delete(currentKey);
    }

    if (startRC.r < 0 || startRC.r >= rows || startRC.c < 0 || startRC.c >= cols || grid[startRC.r]?.[startRC.c] === 0) { // Safe navigation
        error("DFS Error: Start invalid."); return { pathFound: false, path: [] };
    }

    dfsRecursive(startRC, [], new Set());

    if (longestPath.length > 0) {
        log(`DFS finished. Longest path found length: ${longestPath.length}`);
        return { pathFound: true, path: longestPath, end: longestPath[longestPath.length - 1] };
    } else {
        log("DFS finished: No path found to any exit."); return { pathFound: false, path: [] };
    }
}

// --- Path Reconstruction (Not strictly needed for longest DFS, but keep for potential BFS use) ---
function reconstructPath(startRC, endRC, visitedMap) {
     const path = []; let current = endRC; while (current && !(current.r === startRC.r && current.c === startRC.c)) { path.push(current); const parent = visitedMap[current.r]?.[current.c]; if (parent === true || !parent) break; current = parent; } if (current && current.r === startRC.r && current.c === startRC.c) { path.push(startRC); } return path.reverse();
}

// --- DFS Exploration Pathfinding (Async Generator) ---
async function* exploreDFS_Async(grid, startRC, exitRCs) {
    log(`Starting DFS Exploration from ${startRC.r},${startRC.c}`);
    const stack = []; const visited = new Set();
    const rows = grid.length; const cols = grid[0].length;
    const exitSet = new Set(exitRCs.map(e => `${e.r},${e.c}`));
    let foundExit = false;

    if (startRC.r < 0 || startRC.r >= rows || startRC.c < 0 || startRC.c >= cols || grid[startRC.r]?.[startRC.c] === 0) { error("DFS Explore Error: Start invalid."); return false; }

    stack.push(startRC); visited.add(`${startRC.r},${startRC.c}`);
    yield { type: 'forward', coord: startRC };

    while (stack.length > 0) {
        const current = stack[stack.length - 1];
        const currentKey = `${current.r},${current.c}`;

        if (exitSet.has(currentKey)) {
            log(`DFS Exploration reached exit at ${current.r},${current.c}.`);
            foundExit = true;
            // Keep exploring if needed, but for viz we can stop yielding? Or let it finish? Let it finish.
        }

        const neighbors = [ { r: current.r - 1, c: current.c }, { r: current.r + 1, c: current.c }, { r: current.r, c: current.c - 1 }, { r: current.r, c: current.c + 1 } ];
        let foundNeighbor = false;
        for (let i = neighbors.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [neighbors[i], neighbors[j]] = [neighbors[j], neighbors[i]]; }

        for (const n of neighbors) {
            const neighborKey = `${n.r},${n.c}`;
            if (n.r >= 0 && n.r < rows && n.c >= 0 && n.c < cols &&
                grid[n.r]?.[n.c] === 1 && !visited.has(neighborKey)) {
                visited.add(neighborKey); stack.push(n);
                yield { type: 'forward', coord: n };
                foundNeighbor = true; break;
            }
        }

        if (!foundNeighbor) {
            const backtrackCell = stack.pop();
            yield { type: 'backtrack', coord: backtrackCell };
        }
        yield null; // Pacing yield
    }

    log(`DFS Exploration finished ${foundExit ? 'successfully' : 'without finding an exit'}.`);
    return foundExit;
}

// --- DFS Exploration Visualization Function (using runInterval - Concrete Below + Wall Check) ---
function visualizeDFSExplorationWithInterval(dimension, startLocation, dfsExplorer, mazeGrid) {
     return new Promise(async resolve => {
         if (!explorePerm || !backtrackPerm) { error("DFS Viz Perms not ready."); resolve(); return; }
         if (!mazeGrid) { error("DFS Viz Maze Grid not provided."); resolve(); return; }

         log(`Starting async DFS exploration visualization...`);
         const startX = startLocation.x; const startY = startLocation.y; const startZ = startLocation.z;
         let blocksPlacedThisTick = 0;
         const intervalDelay = 1;

         async function processStep() {
             let result;
             try { result = await dfsExplorer.next(); }
             catch (iterError) { error("Error iterating DFS explorer", iterError); resolve(); return; }


             if (!result.done && result.value) {
                 const step = result.value;
                 if (step.coord) {
                     const { type, coord } = step;
                     const r = coord.r; const c = coord.c;
                     const floorLocation = { x: startX + c, y: startY - 1, z: startZ + r };
                     const pathLocation = { x: startX + c, y: startY, z: startZ + r };

                     let blockPermToSet = (type === 'forward') ? explorePerm : backtrackPerm;

                     let blockAtPathLevel = null;
                     try { blockAtPathLevel = dimension.getBlock(pathLocation); } catch (e) {}

                     if (blockAtPathLevel && blockAtPathLevel.typeId === PATH_BLOCK_ID) {
                         try {
                             dimension.setBlockPermutation(floorLocation, blockPermToSet);
                             blocksPlacedThisTick++;
                         } catch (err) { if (Math.random() < 0.05) warn(`DFS Viz error setting block: ${err}`); }
                     }
                 }
                 if (blocksPlacedThisTick >= BLOCKS_PER_TICK_VIZ) {
                     blocksPlacedThisTick = 0; system.runTimeout(processStep, intervalDelay);
                 } else { system.run(processStep); }
             } else if (result.done) {
                 log(`DFS Viz finished.`); resolve();
             } else { system.runTimeout(processStep, intervalDelay); } // Handle null yield
         }
         system.run(processStep); // Start
     });
}


// --- Armor Stand Movement & Path Viz Function (Concrete Below + Wall Check + Start Fix) ---
function moveAndVisualizePath(dimension, solverStand, pathCoords, startLocation, ticksPerStep = 2) {
    return new Promise(resolve => {
        if (!solverStand || !pathCoords || pathCoords.length === 0) { warn("Move/Viz Invalid stand or empty path."); resolve(); return; }
        if (!solverStand.isValid) { warn("Move/Viz Stand invalid before start."); resolve(); return; }
        if (!solutionPerm) { error("Move/Viz Solution Permutation not ready!"); resolve(); return; }

        let pathIndex = 0;
        const totalSteps = pathCoords.length;
        const startX = startLocation.x; const startY = startLocation.y; const startZ = startLocation.z;

        log(`Starting movement & final path visualization along ${totalSteps} steps.`);

        const startCoord = pathCoords[0];
        if (startCoord) {
            const startFloorLocation = { x: startX + startCoord.c, y: startY - 1, z: startZ + startCoord.r };
            const startPathLocation = { x: startX + startCoord.c, y: startY, z: startZ + startCoord.r };
            try {
                const blockAtPath = dimension.getBlock(startPathLocation);
                if (blockAtPath?.typeId === PATH_BLOCK_ID) {
                    dimension.setBlockPermutation(startFloorLocation, solutionPerm);
                    // log("Placed starting block viz."); // Optional log
                } else { warn("Skipped placing start block viz due to non-air above."); }
            } catch(e) { warn(`Failed to set start block: ${e}`); }
        } else { warn("Path has no starting coordinate?"); }

        const intervalId = system.runInterval(() => {
            try {
                if (!solverStand.isValid) { warn("Move/Viz Stand invalid during move."); system.clearRun(intervalId); resolve(); return; }

                pathIndex++; // Increment first to move to next block

                if (pathIndex < totalSteps) {
                    const currentCoord = pathCoords[pathIndex];
                     if (typeof currentCoord?.r !== 'number' || typeof currentCoord?.c !== 'number') { warn(`Move/Viz Invalid coord step ${pathIndex}:`, currentCoord); return; }

                    const targetLocation = { x: startX + currentCoord.c + 0.5, y: startY, z: startZ + currentCoord.r + 0.5 };
                    solverStand.teleport(targetLocation);

                    const floorLocation = { x: startX + currentCoord.c, y: startY - 1, z: startZ + currentCoord.r };
                    const pathLocation = { x: startX + currentCoord.c, y: startY, z: startZ + currentCoord.r };
                    try {
                        const blockAtPath = dimension.getBlock(pathLocation);
                        if (blockAtPath?.typeId === PATH_BLOCK_ID) {
                            dimension.setBlockPermutation(floorLocation, solutionPerm);
                        }
                    } catch (e) { if (Math.random() < 0.02) warn(`Move/Viz Error setting block at ${floorLocation.x},${floorLocation.y},${floorLocation.z}: ${e}`); }

                } else {
                    log("Move/Viz Movement & Visualization finished."); system.clearRun(intervalId); resolve();
                }
            } catch (e) { error("Move/Viz Error during interval", e); system.clearRun(intervalId); resolve(); }
        }, ticksPerStep);
    });
}


// --- Event Listener ---
world.afterEvents.playerPlaceBlock.subscribe((eventData) => {
    // Check if permutations are ready before doing anything
    if (!permutationsReady) {
        warn("Player placed block, but permutations are not ready. Aborting.");
        eventData.player.sendMessage("§cMaze generator is still initializing, please wait a moment.");
        return;
    }

    const { player, block } = eventData;
    let buildWalls = false;
    let triggerId = block.typeId;

    if (triggerId === STONE_TRIGGER_ID) buildWalls = true;
    else if (triggerId === GLASS_TRIGGER_ID) buildWalls = false;
    else return; // Not a trigger block

    const dimension = block.dimension;
    const placedLocation = { x: block.location.x, y: block.location.y, z: block.location.z };
    player.sendMessage(`§eGenerating 41x41 maze (Walls: ${buildWalls}) & preparing solver (${SCRIPT_VERSION})...`);
    try { dimension.setBlockPermutation(placedLocation, pathPerm); } catch(e) { error(`Failed replace trigger block`, e); player.sendMessage("§cError starting maze generation."); return; }

    // Use system.run for the main async logic flow
    system.run(async () => {
        let solverStand = null; // Define solverStand here to be accessible in final catch
        try {
            // 1. Generate Grid
            const mazeGrid = generateMazeGrid_Wilsons();

            // 2. Define Simple Fixed Entrance & Exit
            const entranceRC = { r: 1, c: 1 };
            const exitRC = { r: MAZE_HEIGHT_BLOCKS - 2, c: MAZE_WIDTH_BLOCKS - 2 };
            // Ensure entrance/exit cells are paths and open outer walls
            try {
                if(mazeGrid[entranceRC.r]?.[entranceRC.c] !== 1) mazeGrid[entranceRC.r][entranceRC.c] = 1;
                mazeGrid[0][entranceRC.c] = 1;
                if(mazeGrid[exitRC.r]?.[exitRC.c] !== 1) mazeGrid[exitRC.r][exitRC.c] = 1;
                mazeGrid[MAZE_HEIGHT_BLOCKS - 1][exitRC.c] = 1;
                if(mazeGrid[exitRC.r - 1]?.[exitRC.c] === 0) mazeGrid[exitRC.r - 1][exitRC.c] = 1; // Ensure connection
            } catch (exitError) { warn(`Error forcing entrance/exit: ${exitError}`); }
            const exitRCs = [exitRC];

            // 3. Build Maze Structure (Conditional Walls)
            player.sendMessage(`§6Building maze structure (Walls: ${buildWalls})...`);
            await system.runJob(buildMazeInWorld_Async(dimension, placedLocation, mazeGrid, buildWalls, player));
            player.sendMessage("§6Maze built. Spawning solver...");

            // 4. Spawn Armor Stand
            try {
                const entranceLocation = { x: placedLocation.x + entranceRC.c + 0.5, y: placedLocation.y, z: placedLocation.z + entranceRC.r + 0.5 };
                solverStand = dimension.spawnEntity("minecraft:armor_stand", entranceLocation);
                solverStand.nameTag = ARMOR_STAND_NAME;
            } catch (e) { error("Failed spawn armor stand", e); }

            // 5. Visualize DFS Exploration (if enabled) - Concrete Below
            if (VISUALIZE_EXPLORATION) {
                player.sendMessage("§6Visualizing DFS exploration (Concrete)...");
                const dfsExplorer = exploreDFS_Async(mazeGrid, entranceRC, exitRCs);
                await visualizeDFSExplorationWithInterval(dimension, placedLocation, dfsExplorer, mazeGrid);
                player.sendMessage("§6Exploration visualized.");
            }

            // 6. Run FINAL Pathfinding (Longest DFS)
            player.sendMessage("§6Solver calculating LONGEST path using DFS...");
            const pathResult = findLongestPathDFS(mazeGrid, entranceRC, exitRCs);

            // 7. Process Pathfinding Result
            if (pathResult && pathResult.pathFound) {
                const finalPathCoords = pathResult.path;
                const chosenPathLength = finalPathCoords.length;
                player.sendMessage(`§aLongest DFS Path found! Length: ${chosenPathLength}. Starting solver movement...`);

                // 8. Move Armor Stand Along Path & Visualize Final Path Simultaneously
                await moveAndVisualizePath(dimension, solverStand, finalPathCoords, placedLocation, ARMOR_STAND_TICKS_PER_STEP);
                player.sendMessage("§aSolver reached the exit!");

            } else {
                player.sendMessage("§cPathfinding failed: No path found!");
                if (solverStand && solverStand.isValid) { solverStand.remove(); }
                else { warn("Solver stand invalid or null, cannot remove after failed pathfind."); }
            }

        } catch (genError) {
            error("Error during main maze process", genError);
            player.sendMessage("§cAn error occurred during maze generation or solving.");
            // Attempt to cleanup armor stand on error
            if (solverStand && solverStand.isValid) {
                try { solverStand.remove(); } catch (e) { warn("Failed to remove armor stand during error cleanup."); }
            } else {
                 // Fallback cleanup if stand variable wasn't assigned or became invalid
                 try {
                     warn("Attempting fallback armor stand cleanup...");
                     const stands = dimension.getEntities({ type: 'minecraft:armor_stand', name: ARMOR_STAND_NAME, location: placedLocation, maxDistance: MAZE_WIDTH_BLOCKS + 5 });
                     for (const stand of stands) {
                         if (stand.isValid) stand.remove();
                     }
                 } catch(cleanupError) { error("Error during fallback error cleanup", cleanupError); }
            }
        }
    }); // End system.run
});

console.log(`[MazeGen ${SCRIPT_VERSION}] Wilson's Maze Solver script loaded (Longest DFS, DFS Explore Concrete Viz).`);

import {
    world,
    system,
    ItemStack,
    StartupEvent,
    CommandPermissionLevel,
    CustomCommandStatus
} from "@minecraft/server";

// --- Configuration ---
const OREGEN_NAME = "§l§6O§ar§ee§cgen";
const GENERATION_DELAY_TICKS = 2; // 2 ticks = 0.10 seconds.

// The list of all possible ores it can generate.
const ORE_LIST = [
    "minecraft:coal_ore",
    "minecraft:iron_ore",
    "minecraft:copper_ore",
    "minecraft:gold_ore",
    "minecraft:lapis_ore",
    "minecraft:redstone_ore",
    "minecraft:diamond_ore",
    "minecraft:emerald_ore",
    "minecraft:deepslate_coal_ore",
    "minecraft:deepslate_iron_ore",
    "minecraft:deepslate_copper_ore",
    "minecraft:deepslate_gold_ore",
    "minecraft:deepslate_lapis_ore",
    "minecraft:deepslate_redstone_ore",
    "minecraft:deepslate_diamond_ore",
    "minecraft:deepslate_emerald_ore",
    "minecraft:nether_gold_ore",
    "minecraft:quartz_block", // Changed from nether_quartz_ore as requested
    "minecraft:ancient_debris"
];
// ---------------------

// PART 1: REGISTER THE CUSTOM COMMAND ON STARTUP
system.beforeEvents.startup.subscribe((init) => {
    const oregenCommand = {
        name: "sc:oregen",
        description: "Gives the player the special Oregen block.",
        permissionLevel: CommandPermissionLevel.Admin,
        parameters: []
    };
    init.customCommandRegistry.registerCommand(oregenCommand, oregenCommandCallback);
});

// This function runs when /sc:oregen is used
function oregenCommandCallback(origin) {
    const player = origin.sourceEntity;
    if (!player) return { status: CustomCommandStatus.Fail };

    system.run(() => {
        const oregenItem = new ItemStack('minecraft:iron_ore', 1);
        oregenItem.nameTag = OREGEN_NAME;
        const inventory = player.getComponent('inventory').container;
        inventory.addItem(oregenItem);
        player.sendMessage("§aYou have received the Oregen item!");
    });

    return { status: CustomCommandStatus.Success };
}


// PART 2: HANDLE THE OREGEN BLOCK PLACEMENT
world.afterEvents.playerPlaceBlock.subscribe((eventData) => {
    const { player, block } = eventData;
    const inventory = player.getComponent('inventory').container;
    const heldItem = inventory.getItem(player.selectedSlotIndex);

    if (heldItem && heldItem.typeId === 'minecraft:iron_ore' && heldItem.nameTag === OREGEN_NAME) {
        const startLocation = block.location;
        const dimension = block.dimension;
        player.sendMessage("§eOregen activated! Generating a random ore cube...");

        const blocksToPlace = [];
        for (let y = 0; y < 9; y++) {
            for (let z = 0; z < 7; z++) {
                for (let x = 0; x < 7; x++) {
                    if (x === 0 && y === 0 && z === 0) continue;
                    blocksToPlace.push({
                        x: startLocation.x + x,
                        y: startLocation.y + y,
                        z: startLocation.z + z
                    });
                }
            }
        }

        const intervalId = system.runInterval(() => {
            if (blocksToPlace.length === 0) {
                player.sendMessage("§aOregen generation complete!");
                system.clearRun(intervalId);
                return;
            }

            const nextLocation = blocksToPlace.shift();
            const randomOreIndex = Math.floor(Math.random() * ORE_LIST.length);
            const randomOre = ORE_LIST[randomOreIndex];
            const targetBlock = dimension.getBlock(nextLocation);
            try {
                targetBlock?.setType(randomOre);
            } catch (e) {}
        }, GENERATION_DELAY_TICKS);
    }
});

import { world, system } from '@minecraft/server';

// --- Configuration ---
const FUSE_TIME_TICKS = 45;
const EXPLOSION_RADIUS = 6;
const SPAWN_LAVA = true;
// ---------------------

world.beforeEvents.playerInteractWithBlock.subscribe(eventData => {
  const { player, itemStack, block } = eventData;

  if (!itemStack) {
    return;
  }

  if (itemStack.typeId === 'minecraft:gunpowder' && block.typeId === 'minecraft:barrel') {
    
    eventData.cancel = true;

    const locationSnapshot = { 
      x: block.location.x, 
      y: block.location.y, 
      z: block.location.z 
    };
    
    const dimension = player.dimension;

    system.run(() => {
        // ADDED: Play the fuse sound immediately as requested.
        dimension.playSound("random.fuse", locationSnapshot);

        // --- Consume the item ---
        const inventory = player.getComponent('inventory').container;
        const heldItem = inventory.getItem(player.selectedSlotIndex); 

        if (heldItem && heldItem.typeId === 'minecraft:gunpowder') {
            if (heldItem.amount > 1) {
                heldItem.amount -= 1;
                inventory.setItem(player.selectedSlotIndex, heldItem);
            } else {
                inventory.setItem(player.selectedSlotIndex, undefined);
            }
        }

        // --- Replace the barrel with a TNT ENTITY ---
        const sourceBlock = dimension.getBlock(locationSnapshot);
        if (sourceBlock) {
            sourceBlock.setType('minecraft:air');
            const tntEntityLocation = { x: locationSnapshot.x + 0.5, y: locationSnapshot.y, z: locationSnapshot.z + 0.5 };
            dimension.spawnEntity('minecraft:tnt', tntEntityLocation);
        }

        // --- Schedule the custom explosion ---
        system.runTimeout(() => {
          
          const tntEntities = dimension.getEntities({
            type: 'minecraft:tnt',
            location: locationSnapshot,
            maxDistance: 2
          });
          for (const tnt of tntEntities) {
            tnt.kill();
          }

          dimension.createExplosion(locationSnapshot, EXPLOSION_RADIUS, {
            breaksBlocks: true,
            causesFire: true,
          });

          // This remains here to play 45 ticks later as requested.
          dimension.playSound("random.explode", locationSnapshot);

          if (SPAWN_LAVA) {
            dimension.getBlock(locationSnapshot)?.setType('minecraft:flowing_lava');
          }
        }, FUSE_TIME_TICKS);
    });
  }
});

import { world, ItemStack } from '@minecraft/server';

console.warn("§a[Chaos Wand] Script Loaded");

world.afterEvents.entityHitEntity.subscribe((event) => {
    const { damagingEntity, hitEntity } = event;

    if (!damagingEntity || damagingEntity.typeId !== 'minecraft:player') return;
    const player = damagingEntity;

    const inventory = player.getComponent('inventory').container;
    const item = inventory.getItem(player.selectedSlotIndex);

    if (!item || item.typeId !== 'minecraft:stick' || item.nameTag !== "Chaos Wand") return;
    if (!hitEntity || !hitEntity.isValid) return;

    const chance = Math.random();
    const dimension = hitEntity.dimension;
    const loc = hitEntity.location;

    try {
        if (chance < 0.15) {
            player.sendMessage("§b[Chaos] YEET!");
            hitEntity.applyImpulse({ x: 0, y: 2.5, z: 0 });
            dimension.playSound("game.player.attack.strong", loc);
        } 
        else if (chance < 0.30) {
            const mobs = ["minecraft:creeper", "minecraft:cow", "minecraft:sheep", "minecraft:chicken", "minecraft:pig", "minecraft:spider"];
            const randomMob = mobs[Math.floor(Math.random() * mobs.length)];
            
            player.sendMessage(`§d[Chaos] Polymorph: ${hitEntity.typeId} -> ${randomMob}`);
            
            dimension.spawnEntity(randomMob, loc);
            hitEntity.remove();
            dimension.spawnParticle("minecraft:large_explosion", loc);
        }
        else if (chance < 0.45) {
            player.sendMessage("§5[Chaos] Swapped!");
            const playerLoc = player.location;
            
            player.teleport(loc, { dimension: dimension, facingLocation: playerLoc });
            
            if (hitEntity.isValid) {
                hitEntity.teleport(playerLoc, { dimension: dimension });
            }
            dimension.playSound("mob.shulker.teleport", loc);
        }
        else if (chance < 0.60) {
            player.sendMessage("§e[Chaos] SMITE!");
            dimension.spawnEntity("minecraft:lightning_bolt", loc);
        }
        else if (chance < 0.70) {
            player.sendMessage("§a[Chaos] Mitosis!");
            const type = hitEntity.typeId;
            dimension.spawnEntity(type, loc);
            dimension.spawnEntity(type, loc);
        }
        else if (chance < 0.80) {
            player.sendMessage("§c[Chaos] Boom.");
            dimension.createExplosion(loc, 2, { breaksBlocks: false, causesFire: false });
            hitEntity.applyImpulse({ x: 0, y: 1, z: 0 });
        }
        else if (chance < 0.90) {
            player.sendMessage("§6[Chaos] It's your lucky day!");
            dimension.spawnItem(new ItemStack("minecraft:diamond"), loc);
            dimension.playSound("random.levelup", loc);
        }
        else {
            player.sendMessage("§7[Chaos] ...Nothing happened.");
            dimension.playSound("random.burp", loc);
        }

    } catch (error) {
        console.warn(`Chaos Error: ${error}`);
    }
});

import { world, system } from '@minecraft/server';

// --- CONFIGURATION ---
const PHASE_ITEM = 'minecraft:soul_sand';
const PHASE_NAME = 'Phase Key';
const RESTORE_DELAY = 8; // Slightly longer to prevent flickering
const PREDICTION_AMOUNT = 2.0; 

const BLACKLIST = [
    "minecraft:bedrock",
    "minecraft:obsidian",
    "minecraft:chest",
    "minecraft:trapped_chest",
    "minecraft:barrel",
    "minecraft:shulker_box",
    "minecraft:ender_chest",
    "minecraft:portal",
    "minecraft:end_portal",
    "minecraft:end_portal_frame",
    "minecraft:command_block",
    "minecraft:repeating_command_block",
    "minecraft:chain_command_block"
];

// Map<StringKey, { perm: BlockPermutation, restoreTick: number }>
const ghostMemory = new Map();

system.runInterval(() => {
    const currentTick = system.currentTick;

    // --- 1. RESTORE BLOCKS ---
    for (const [key, data] of ghostMemory) {
        if (currentTick >= data.restoreTick) {
            try {
                const parts = key.split('|');
                const x = Number(parts[0]);
                const y = Number(parts[1]);
                const z = Number(parts[2]);
                const dimId = parts[3];

                const dimension = world.getDimension(dimId);
                
                if (y < -64 || y > 320) {
                    ghostMemory.delete(key);
                    continue;
                }

                const block = dimension.getBlock({ x, y, z });

                if (block && block.typeId === 'minecraft:air') {
                    
                    // ANTI-SUFFOCATION: Check if any player is inside this block
                    let isBlocked = false;
                    for (const p of dimension.getPlayers()) {
                        const pLoc = p.location;
                        // Hitbox check
                        if (Math.abs(pLoc.x - (x + 0.5)) < 0.8 &&
                            pLoc.y >= y - 1.0 && pLoc.y <= y + 1.8 &&
                            Math.abs(pLoc.z - (z + 0.5)) < 0.8) {
                            isBlocked = true;
                            break;
                        }
                    }

                    if (isBlocked) {
                        data.restoreTick = currentTick + 3; // Keep open
                        continue; 
                    }

                    block.setPermutation(data.perm);
                }
            } catch (e) {}
            
            ghostMemory.delete(key);
        }
    }

    // --- 2. PHASE LOGIC ---
    for (const player of world.getPlayers()) {
        const inventory = player.getComponent('inventory').container;
        const item = inventory.getItem(player.selectedSlotIndex);

        if (!item || item.typeId !== PHASE_ITEM || item.nameTag !== PHASE_NAME) continue;

        const dim = player.dimension;
        const loc = player.location;
        const vel = player.getVelocity();
        const view = player.getViewDirection();

        try { dim.spawnParticle("minecraft:soul_particle", loc); } catch(e){}

        // List of coordinates to melt
        const positionsToCheck = [];

        // Helper to add a position (Head + Feet)
        const addPos = (baseX, baseY, baseZ) => {
            positionsToCheck.push({ x: Math.floor(baseX), y: Math.floor(baseY), z: Math.floor(baseZ) });
            positionsToCheck.push({ x: Math.floor(baseX), y: Math.floor(baseY + 1), z: Math.floor(baseZ) });
        };

        // A. Current Position
        addPos(loc.x, loc.y, loc.z);

        // B. View Direction (The "Nose" Check)
        // This fixes the issue where standing close to a wall didn't melt it.
        // We check 0.8 blocks in front of your eyes.
        addPos(loc.x + (view.x * 0.8), loc.y, loc.z + (view.z * 0.8));

        // C. Velocity Prediction (The "Sprint" Check)
        if (Math.abs(vel.x) > 0.05 || Math.abs(vel.z) > 0.05) {
            addPos(loc.x + (vel.x * PREDICTION_AMOUNT), loc.y, loc.z + (vel.z * PREDICTION_AMOUNT));
        }

        // Process the list
        for (const pos of positionsToCheck) {
            const key = `${pos.x}|${pos.y}|${pos.z}|${dim.id}`;

            if (ghostMemory.has(key)) {
                const entry = ghostMemory.get(key);
                entry.restoreTick = currentTick + RESTORE_DELAY;
                continue;
            }

            try {
                if (pos.y < -64 || pos.y > 320) continue;

                const block = dim.getBlock(pos);
                if (!block || block.isAir || block.isLiquid) continue;
                if (BLACKLIST.includes(block.typeId)) continue;

                ghostMemory.set(key, {
                    perm: block.permutation,
                    restoreTick: currentTick + RESTORE_DELAY
                });

                block.setType('minecraft:air');

            } catch (e) {}
        }
    }
});

import { world, system } from '@minecraft/server';

console.warn("§a[Cluster Grenade V2] Tracker System Loaded!");

// --- CONFIGURATION ---
const GRENADE_NAME = "Cluster Grenade";
const MAX_GENERATIONS = 3; 
const CLUSTER_COUNT = 5;   
const SPREAD_POWER = 0.8;  

// --- TRACKING SYSTEM ---
// Map<EntityID, { entity: Entity, gen: number, lastLoc: Vector3, dimension: Dimension }>
const activeGrenades = new Map();

// 1. THE MONITORING LOOP
// This runs every tick to check on our grenades
system.runInterval(() => {
    for (const [id, data] of activeGrenades) {
        // CASE A: The Grenade is still flying
        if (data.entity.isValid) {
            // Update its last known location (so we know where it explodes)
            try {
                data.lastLoc = data.entity.location;
            } catch (e) {
                // Entity might have just died/unloaded
            }
        } 
        // CASE B: The Grenade has died (Hit something)
        else {
            triggerExplosion(data);
            activeGrenades.delete(id); // Stop tracking
        }
    }
});

// 2. EXPLOSION LOGIC
function triggerExplosion(data) {
    const { lastLoc, gen, dimension } = data;
    
    if (!lastLoc) return; // Safety check

    // Calculate Power (Gen 1 = 4, Gen 2 = 3, etc.)
    const power = 4 - gen;

    try {
        // BOOM
        dimension.createExplosion(lastLoc, power, { 
            breaksBlocks: false, 
            causesFire: true 
        });

        // SPAWN CHILDREN (Recursion)
        if (gen < MAX_GENERATIONS) {
            const nextGen = gen + 1;

            for (let i = 0; i < CLUSTER_COUNT; i++) {
                const spawnLoc = { x: lastLoc.x, y: lastLoc.y + 0.5, z: lastLoc.z };
                
                // Spawn Child Egg
                const child = dimension.spawnEntity("minecraft:egg", spawnLoc);
                
                // Add Child to Tracker immediately
                activeGrenades.set(child.id, {
                    entity: child,
                    gen: nextGen,
                    lastLoc: spawnLoc,
                    dimension: dimension
                });

                // Physics (Yeet)
                const rx = (Math.random() - 0.5) * SPREAD_POWER;
                const ry = (Math.random() * 0.5) + 0.5; // Upwards
                const rz = (Math.random() - 0.5) * SPREAD_POWER;
                
                child.applyImpulse({ x: rx, y: ry, z: rz });
            }
        }
    } catch (e) {
        // Ignore errors if explosion happens in unloaded chunk
    }
}

// 3. START THE PROCESS (Item Use)
world.afterEvents.itemUse.subscribe((event) => {
    const { source, itemStack } = event;
    
    if (itemStack.typeId === 'minecraft:egg' && itemStack.nameTag === GRENADE_NAME) {
        const dim = source.dimension;
        const headLoc = source.getHeadLocation();
        
        // Wait 1 tick to find the projectile that was just thrown
        system.run(() => {
            // Find closest egg to player's face
            const entities = dim.getEntities({
                type: 'minecraft:egg',
                location: headLoc,
                maxDistance: 4,
                closest: 1
            });

            if (entities.length > 0) {
                const egg = entities[0];
                
                // Check if we are already tracking it (prevent duplicates)
                if (!activeGrenades.has(egg.id)) {
                    // Add to Tracker as Generation 1
                    activeGrenades.set(egg.id, {
                        entity: egg,
                        gen: 1,
                        lastLoc: egg.location,
                        dimension: dim
                    });
                }
            }
        });
    }
});

import { world, system, ItemStack, EntityComponentTypes, EquipmentSlot } from '@minecraft/server';

console.warn("§a[Temporal Echo V5] Armor Stand & Inventory Fix Loaded!");

// --- CONFIGURATION ---
const RECORD_ITEM = 'minecraft:clock';
const RECORD_NAME = 'Time Recorder';
const REPLAY_ITEM = 'minecraft:compass';
const REPLAY_NAME = 'Time Replay';
const MAX_RECORD_TICKS = 1200; 

// --- DATA STRUCTURES ---
const recorderData = new Map();
const activeReplays = new Map();

class Frame {
    constructor(player, events) {
        this.loc = { ...player.location };
        this.rot = player.getRotation();
        this.isSneaking = player.isSneaking;
        
        // FIX 1: Use Inventory Container for Player Recording (More Reliable)
        const inv = player.getComponent('inventory').container;
        const mainItem = inv.getItem(player.selectedSlotIndex);
        
        // For Offhand, we still use Equippable
        const equip = player.getComponent(EntityComponentTypes.Equippable);
        const offItem = equip.getEquipment(EquipmentSlot.Offhand);
        
        this.mainItem = mainItem ? mainItem.typeId : 'minecraft:air';
        this.offItem = offItem ? offItem.typeId : 'minecraft:air';
        this.events = events || [];
    }
}

// --- 1. INVENTORY SNAPSHOT ---
function savePlayerState(player) {
    const inv = player.getComponent('inventory').container;
    const equip = player.getComponent(EntityComponentTypes.Equippable);

    const items = [];
    for (let i = 0; i < inv.size; i++) {
        const item = inv.getItem(i);
        if (item) items.push({ slot: i, itemStack: item.clone() });
    }

    const equipment = {
        head: equip.getEquipment(EquipmentSlot.Head)?.clone(),
        chest: equip.getEquipment(EquipmentSlot.Chest)?.clone(),
        legs: equip.getEquipment(EquipmentSlot.Legs)?.clone(),
        feet: equip.getEquipment(EquipmentSlot.Feet)?.clone(),
        offhand: equip.getEquipment(EquipmentSlot.Offhand)?.clone()
    };

    return { items, equipment };
}

function restorePlayerState(player, state) {
    const inv = player.getComponent('inventory').container;
    const equip = player.getComponent(EntityComponentTypes.Equippable);

    inv.clearAll();
    
    // Restore Items
    for (const entry of state.items) {
        try {
            inv.setItem(entry.slot, entry.itemStack);
        } catch (e) {
            console.warn(`Failed to restore item in slot ${entry.slot}: ${e}`);
        }
    }

    // Restore Equipment
    try { equip.setEquipment(EquipmentSlot.Head, state.equipment.head); } catch(e){}
    try { equip.setEquipment(EquipmentSlot.Chest, state.equipment.chest); } catch(e){}
    try { equip.setEquipment(EquipmentSlot.Legs, state.equipment.legs); } catch(e){}
    try { equip.setEquipment(EquipmentSlot.Feet, state.equipment.feet); } catch(e){}
    try { equip.setEquipment(EquipmentSlot.Offhand, state.equipment.offhand); } catch(e){}

    player.sendMessage("§a[Time] Inventory Restored.");
    player.playSound("random.levelup");
}

// --- 2. EVENT CAPTURE ---
function logEvent(player, eventName, blockLocation = null) {
    const data = recorderData.get(player.id);
    if (data && data.isRecording) {
        if (!data.tempEvents) data.tempEvents = [];
        data.tempEvents.push({ name: eventName, loc: blockLocation });
    }
}

world.afterEvents.entityHitEntity.subscribe((e) => {
    if (e.damagingEntity.typeId === 'minecraft:player') logEvent(e.damagingEntity, "attack");
});
world.afterEvents.playerBreakBlock.subscribe((e) => {
    logEvent(e.player, "attack");
});
world.afterEvents.playerInteractWithBlock.subscribe((e) => {
    const block = e.block;
    const type = block.typeId;
    const loc = block.location;

    if (type.includes("barrel")) logEvent(e.player, "open_barrel", loc);
    else if (type.includes("chest")) logEvent(e.player, "open_chest", loc);
    else if (type.includes("door")) logEvent(e.player, "toggle_door", loc);
    else if (type.includes("trapdoor")) logEvent(e.player, "toggle_trapdoor", loc);
    else if (type.includes("fence_gate")) logEvent(e.player, "toggle_gate", loc);
    else if (type.includes("lever")) logEvent(e.player, "toggle_lever", loc);
    else if (type.includes("button")) logEvent(e.player, "press_button", loc);
    else logEvent(e.player, "interact", loc);
});

// --- 3. CONTROLS ---
world.afterEvents.itemUse.subscribe((event) => {
    const { source: player, itemStack } = event;

    if (itemStack.typeId === RECORD_ITEM && itemStack.nameTag === RECORD_NAME) {
        let data = recorderData.get(player.id);

        if (data && data.isRecording) {
            // STOP
            data.isRecording = false;
            player.sendMessage(`§e[Time] Stopped. Saved ${data.frames.length} ticks.`);
            player.playSound("random.click");
            if (data.initialState) restorePlayerState(player, data.initialState);
        } else {
            // START
            const snapshot = savePlayerState(player);
            recorderData.set(player.id, { 
                frames: [], 
                isRecording: true, 
                tempEvents: [],
                initialState: snapshot 
            });
            player.sendMessage("§c[Time] Recording... (Inventory Saved)");
            player.playSound("random.click");
        }
    }

    if (itemStack.typeId === REPLAY_ITEM && itemStack.nameTag === REPLAY_NAME) {
        const data = recorderData.get(player.id);
        if (!data || data.frames.length === 0) {
            player.sendMessage("§c[Time] No recording found.");
            return;
        }
        if (data.isRecording) {
            player.sendMessage("§c[Time] Stop recording first!");
            return;
        }
        startReplay(player, data.frames);
    }
});

// --- 4. MAIN LOOP ---
system.runInterval(() => {
    // A. RECORDING
    for (const player of world.getPlayers()) {
        const data = recorderData.get(player.id);
        if (data && data.isRecording) {
            if (data.frames.length >= MAX_RECORD_TICKS) {
                data.isRecording = false;
                player.sendMessage("§c[Time] Memory Full.");
                if (data.initialState) restorePlayerState(player, data.initialState);
                continue;
            }
            data.frames.push(new Frame(player, data.tempEvents));
            data.tempEvents = [];
            player.onScreenDisplay.setActionBar(`§c● REC [${data.frames.length}]`);
        }
    }

    // B. REPLAY
    for (const [playerId, replay] of activeReplays) {
        if (replay.currentTick >= replay.frames.length) {
            endReplay(playerId);
            continue;
        }

        const frame = replay.frames[replay.currentTick];
        const entity = replay.entity;

        if (!entity || !entity.isValid) {
            activeReplays.delete(playerId);
            continue;
        }

        // 1. Move
        entity.teleport(frame.loc, {
            dimension: entity.dimension,
            rotation: frame.rot
        });

        // 2. Equip Sync
        const prevFrame = replay.currentTick > 0 ? replay.frames[replay.currentTick - 1] : null;
        const equip = entity.getComponent(EntityComponentTypes.Equippable);

        if (equip) {
            // Mainhand
            if (!prevFrame || prevFrame.mainItem !== frame.mainItem) {
                if (frame.mainItem === 'minecraft:air') {
                    equip.setEquipment(EquipmentSlot.Mainhand, undefined);
                } else {
                    try { equip.setEquipment(EquipmentSlot.Mainhand, new ItemStack(frame.mainItem, 1)); } catch(e){}
                }
            }
            // Offhand
            if (!prevFrame || prevFrame.offItem !== frame.offItem) {
                if (frame.offItem === 'minecraft:air') {
                    equip.setEquipment(EquipmentSlot.Offhand, undefined);
                } else {
                    try { equip.setEquipment(EquipmentSlot.Offhand, new ItemStack(frame.offItem, 1)); } catch(e){}
                }
            }
        }

        // 3. Pose
        entity.nameTag = frame.isSneaking ? "§7[Sneaking]" : "§b[Echo]";

        // 4. Events
        if (frame.events && frame.events.length > 0) {
            for (const evtObj of frame.events) {
                const evt = evtObj.name;
                const bLoc = evtObj.loc;
                const loc = entity.location;
                const dim = entity.dimension;

                if (evt === "attack") {
                    dim.playSound("game.player.attack.nodamage", loc);
                    dim.spawnParticle("minecraft:crit_particle", { x: loc.x, y: loc.y + 1.5, z: loc.z });
                } 
                else if (evt === "open_barrel") {
                    dim.playSound("block.barrel.open", loc);
                    dim.spawnParticle("minecraft:villager_happy", loc);
                }
                else if (evt === "open_chest") dim.playSound("random.chestopen", loc);
                else if (["toggle_door", "toggle_trapdoor", "toggle_gate", "toggle_lever"].includes(evt) && bLoc) {
                    try {
                        const block = dim.getBlock(bLoc);
                        if (block) {
                            const perm = block.permutation;
                            let isOpen = perm.getState("open_bit");
                            let stateName = "open_bit";
                            if (isOpen === undefined) { isOpen = perm.getState("open"); stateName = "open"; }
                            if (isOpen !== undefined) {
                                block.setPermutation(perm.withState(stateName, !isOpen));
                                dim.playSound("random.click", bLoc);
                            }
                        }
                    } catch (e) {}
                }
                else if (evt === "press_button" && bLoc) {
                    try {
                        const block = dim.getBlock(bLoc);
                        if (block) {
                            const perm = block.permutation;
                            block.setPermutation(perm.withState("button_pressed_bit", true));
                            dim.playSound("random.click", bLoc);
                            system.runTimeout(() => {
                                try { block.setPermutation(perm.withState("button_pressed_bit", false)); } catch(e){}
                            }, 20);
                        }
                    } catch (e) {}
                }
            }
        }

        replay.currentTick++;
    }
}, 1);

// --- 5. REPLAY HELPERS ---
function startReplay(player, frames) {
    if (activeReplays.has(player.id)) endReplay(player.id);

    const startFrame = frames[0];
    const dim = player.dimension;

    try {
        const ghost = dim.spawnEntity("minecraft:armor_stand", startFrame.loc);
        ghost.nameTag = "§b[Echo]";
        ghost.addTag("temporal_ghost");
        
        // FIX 2: Explicitly set equipment on spawn
        const ghostEquip = ghost.getComponent(EntityComponentTypes.Equippable);
        const playerEquip = player.getComponent(EntityComponentTypes.Equippable);
        
        if (ghostEquip && playerEquip) {
            // Armor
            ghostEquip.setEquipment(EquipmentSlot.Head, playerEquip.getEquipment(EquipmentSlot.Head));
            ghostEquip.setEquipment(EquipmentSlot.Chest, playerEquip.getEquipment(EquipmentSlot.Chest));
            ghostEquip.setEquipment(EquipmentSlot.Legs, playerEquip.getEquipment(EquipmentSlot.Legs));
            ghostEquip.setEquipment(EquipmentSlot.Feet, playerEquip.getEquipment(EquipmentSlot.Feet));
            
            // FIX 3: Set Mainhand/Offhand immediately from the first frame
            if (startFrame.mainItem !== 'minecraft:air') {
                try { ghostEquip.setEquipment(EquipmentSlot.Mainhand, new ItemStack(startFrame.mainItem, 1)); } catch(e){}
            }
            if (startFrame.offItem !== 'minecraft:air') {
                try { ghostEquip.setEquipment(EquipmentSlot.Offhand, new ItemStack(startFrame.offItem, 1)); } catch(e){}
            }
        }

        activeReplays.set(player.id, {
            entity: ghost,
            frames: frames,
            currentTick: 0
        });

        player.sendMessage("§a[Time] Replaying...");
    } catch (e) {
        player.sendMessage(`§cError: ${e}`);
    }
}

function endReplay(playerId) {
    const replay = activeReplays.get(playerId);
    if (replay && replay.entity && replay.entity.isValid) {
        replay.entity.dimension.spawnParticle("minecraft:cloud_particle", replay.entity.location);
        replay.entity.remove();
    }
    activeReplays.delete(playerId);
}

system.run(() => {
    const dims = [world.getDimension("overworld"), world.getDimension("nether"), world.getDimension("the_end")];
    for (const d of dims) {
        for (const e of d.getEntities({ tags: ["temporal_ghost"] })) e.remove();
    }
});

import { world, system, EffectTypes } from '@minecraft/server';

console.warn("§a[Mob Cannon V2] Stacker Edition Loaded!");

// --- CONFIGURATION ---
const CANNON_ITEM = 'minecraft:blaze_rod';
const CANNON_NAME = 'Mob Cannon';
const GRAB_RANGE = 10;
const HOLD_DISTANCE = 3; 
const LAUNCH_POWER = 2.5; 
const STACK_HEIGHT = 1.1; // Distance between stacked mobs

// Track who is holding what: Map<PlayerID, Array<EntityID>>
const heldMobs = new Map();

// --- 1. THE CONTROL LOGIC ---
world.afterEvents.itemUse.subscribe((event) => {
    const { source: player, itemStack } = event;

    if (itemStack.typeId !== CANNON_ITEM || itemStack.nameTag !== CANNON_NAME) return;

    // SNEAKING = GRAB (Add to stack)
    if (player.isSneaking) {
        grabMob(player);
    } 
    // STANDING = LAUNCH (Yeet all)
    else {
        launchMobs(player);
    }
});

// --- 2. GRAB FUNCTION ---
function grabMob(player) {
    const dimension = player.dimension;
    
    // Get current stack or create new one
    let stack = heldMobs.get(player.id) || [];

    const nearbyEntities = dimension.getEntities({
        location: player.location,
        maxDistance: GRAB_RANGE,
        excludeTypes: ['minecraft:player', 'minecraft:item', 'minecraft:arrow', 'minecraft:xp_orb']
    });

    let target = null;
    let minDistance = 999;
    const viewDir = player.getViewDirection();

    for (const entity of nearbyEntities) {
        // Skip if already in the stack
        if (stack.includes(entity.id)) continue;

        const dx = entity.location.x - player.location.x;
        const dy = entity.location.y - player.location.y;
        const dz = entity.location.z - player.location.z;

        const dot = (dx * viewDir.x) + (dy * viewDir.y) + (dz * viewDir.z);
        
        if (dot > 0) { 
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            if (dist < minDistance) {
                minDistance = dist;
                target = entity;
            }
        }
    }

    if (target) {
        stack.push(target.id);
        heldMobs.set(player.id, stack);
        
        player.playSound("mob.endermen.portal");
        player.sendMessage(`§a[Cannon] Added to stack! (Count: ${stack.length})`);
        
        try {
            target.addEffect(EffectTypes.get("resistance"), 20000, { amplifier: 255, showParticles: false });
        } catch (e) {}
    } else {
        player.sendMessage("§c[Cannon] No new target found.");
    }
}

// --- 3. LAUNCH FUNCTION ---
function launchMobs(player) {
    const stack = heldMobs.get(player.id);
    
    if (!stack || stack.length === 0) {
        player.sendMessage("§c[Cannon] Nothing to launch.");
        return;
    }

    const viewDir = player.getViewDirection();
    let launchedCount = 0;

    for (const mobId of stack) {
        const mob = world.getEntity(mobId);
        
        if (mob && mob.isValid) {
            // Add slight random spread so they don't fuse into one entity
            const spreadX = (Math.random() - 0.5) * 0.2;
            const spreadZ = (Math.random() - 0.5) * 0.2;

            mob.applyImpulse({
                x: (viewDir.x + spreadX) * LAUNCH_POWER * 2,
                y: (viewDir.y * LAUNCH_POWER) + 0.5,
                z: (viewDir.z + spreadZ) * LAUNCH_POWER * 2
            });
            launchedCount++;
        }
    }

    if (launchedCount > 0) {
        player.playSound("mob.ghast.fireball");
        player.sendMessage(`§c[Cannon] YEETED ${launchedCount} MOBS!`);
    }

    heldMobs.delete(player.id);
}

// --- 4. PHYSICS LOOP (The Totem Pole) ---
system.runInterval(() => {
    for (const [playerId, stack] of heldMobs) {
        const player = world.getEntity(playerId);
        
        if (!player || !player.isValid) {
            heldMobs.delete(playerId);
            continue;
        }

        // Filter out dead mobs from the stack
        const validStack = stack.filter(id => {
            const m = world.getEntity(id);
            return m && m.isValid;
        });

        // Update the map if mobs died
        if (validStack.length !== stack.length) {
            heldMobs.set(playerId, validStack);
        }

        if (validStack.length === 0) continue;

        // Calculate Base Position
        const viewDir = player.getViewDirection();
        const playerLoc = player.location;
        
        // Base is in front of player
        let currentPos = {
            x: playerLoc.x + (viewDir.x * HOLD_DISTANCE),
            y: playerLoc.y + (viewDir.y * HOLD_DISTANCE) + 0.5,
            z: playerLoc.z + (viewDir.z * HOLD_DISTANCE)
        };

        // Loop through stack and place them on top of each other
        for (let i = 0; i < validStack.length; i++) {
            const mob = world.getEntity(validStack[i]);
            
            if (mob) {
                mob.teleport(currentPos, { 
                    dimension: player.dimension, 
                    facingLocation: playerLoc 
                });
                
                mob.clearVelocity();

                // Move the position UP for the next mob
                currentPos.y += STACK_HEIGHT;
            }
        }
        
        // Visuals at the base
        try {
            const basePos = {
                x: playerLoc.x + (viewDir.x * HOLD_DISTANCE),
                y: playerLoc.y + (viewDir.y * HOLD_DISTANCE) + 1.5,
                z: playerLoc.z + (viewDir.z * HOLD_DISTANCE)
            };
            player.dimension.spawnParticle("minecraft:endrod", basePos);
        } catch (e) {}
    }
});

import { world, system, EffectTypes } from '@minecraft/server';

console.warn("§a[Homing Missile V5] Direct Movement System Loaded.");

// --- CONFIGURATION ---
const MISSILE_SPEED = 0.6; // Blocks per tick (0.6 * 20 = 12 blocks/second)
const SEARCH_RADIUS = 40;
const EXPLOSION_RADIUS = 4;
const DEBUG_MODE = true; 

const IGNORE_LIST = [
    "minecraft:player", 
    "minecraft:chicken", 
    "minecraft:item", 
    "minecraft:egg", 
    "minecraft:arrow", 
    "minecraft:xp_orb", 
    "minecraft:armor_stand",
    "minecraft:splash_potion"
];

// --- 1. SPAWN LOGIC ---
function spawnMissile(dimension, location) {
    try {
        const spawnLoc = { x: location.x, y: location.y + 1.0, z: location.z };
        const chicken = dimension.spawnEntity("minecraft:chicken", spawnLoc);
        
        chicken.nameTag = "§cSEARCHING...";
        chicken.addTag("missile_chicken");
        
        // Make it silent and invincible
        chicken.addEffect(EffectTypes.get("resistance"), 20000, { amplifier: 255, showParticles: false });
        
        dimension.playSound("fuse", spawnLoc);
        dimension.spawnParticle("minecraft:huge_explosion_emitter", spawnLoc);
    } catch (e) {
        console.warn(`Spawn Error: ${e}`);
    }
}

world.afterEvents.projectileHitBlock.subscribe((e) => {
    if (e.projectile.typeId === 'minecraft:egg') spawnMissile(e.dimension, e.location);
});
world.afterEvents.projectileHitEntity.subscribe((e) => {
    if (e.projectile.typeId === 'minecraft:egg') spawnMissile(e.dimension, e.location);
});

// --- 2. AI LOOP ---
system.runInterval(() => {
    const dimensions = [world.getDimension("overworld"), world.getDimension("nether"), world.getDimension("the_end")];

    for (const dimension of dimensions) {
        const missiles = dimension.getEntities({ tags: ["missile_chicken"] });

        for (const chicken of missiles) {
            if (!chicken.isValid) continue;

            // --- STEP A: RETRIEVE LOCKED TARGET ---
            let targetEntity = null;
            const lockedTargetId = chicken.getDynamicProperty("targetId");

            if (lockedTargetId) {
                targetEntity = world.getEntity(lockedTargetId);
                
                if (!targetEntity || !targetEntity.isValid || targetEntity.dimension.id !== dimension.id) {
                    chicken.setDynamicProperty("targetId", undefined);
                    chicken.nameTag = "§eLOST TARGET";
                    targetEntity = null;
                }
            }

            // --- STEP B: SCAN FOR NEW TARGET ---
            if (!targetEntity) {
                const nearbyEntities = dimension.getEntities({
                    location: chicken.location,
                    maxDistance: SEARCH_RADIUS,
                    excludeTypes: IGNORE_LIST
                });

                let closest = null;
                let minDst = 999;

                for (const entity of nearbyEntities) {
                    const d = Math.sqrt(
                        Math.pow(entity.location.x - chicken.location.x, 2) +
                        Math.pow(entity.location.y - chicken.location.y, 2) +
                        Math.pow(entity.location.z - chicken.location.z, 2)
                    );

                    if (d < minDst) {
                        minDst = d;
                        closest = entity;
                    }
                }

                if (closest) {
                    chicken.setDynamicProperty("targetId", closest.id);
                    targetEntity = closest;
                    chicken.nameTag = `§cLOCKED: ${closest.typeId.replace("minecraft:", "").toUpperCase()}`;
                    if (DEBUG_MODE) world.sendMessage(`§a[Missile] Locked onto ${closest.typeId}`);
                }
            }

            // --- STEP C: DIRECT MOVEMENT (TELEPORTATION) ---
            if (targetEntity) {
                const cLoc = chicken.location;
                const tLoc = targetEntity.location;

                // 1. Check Distance for Explosion
                const dist = Math.sqrt(
                    Math.pow(tLoc.x - cLoc.x, 2) +
                    Math.pow(tLoc.y - cLoc.y, 2) +
                    Math.pow(tLoc.z - cLoc.z, 2)
                );

                if (dist < 1.5) {
                    explode(chicken);
                    continue;
                }

                // 2. Calculate Direction Vector
                const dx = tLoc.x - cLoc.x;
                const dy = (tLoc.y + 0.8) - cLoc.y; // Aim slightly up (center of mass)
                const dz = tLoc.z - cLoc.z;
                
                // Normalize (make length 1)
                const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                // 3. Calculate NEXT Position
                // NewPos = CurrentPos + (Direction * Speed)
                const nextPos = {
                    x: cLoc.x + (dx / len) * MISSILE_SPEED,
                    y: cLoc.y + (dy / len) * MISSILE_SPEED,
                    z: cLoc.z + (dz / len) * MISSILE_SPEED
                };

                // 4. Teleport to next position (Movement + Rotation)
                // We check for blocks to avoid getting stuck inside walls forever, 
                // but for a missile, clipping is usually fine.
                chicken.teleport(nextPos, { facingLocation: tLoc });
                
                dimension.spawnParticle("minecraft:basic_flame_particle", cLoc);

            } else {
                // --- IDLE MODE ---
                // Float Upwards slowly
                const nextPos = {
                    x: chicken.location.x,
                    y: chicken.location.y + 0.1,
                    z: chicken.location.z
                };
                
                // Spin
                const tick = system.currentTick;
                chicken.teleport(nextPos, { rotation: { x: 0, y: tick * 15 } });
            }
        }
    }
});

function explode(chicken) {
    const dim = chicken.dimension;
    const loc = chicken.location;
    chicken.remove();
    dim.createExplosion(loc, EXPLOSION_RADIUS, { breaksBlocks: false, causesFire: true });
    dim.spawnParticle("minecraft:huge_explosion_emitter", loc);
}

import { world, system, Direction } from '@minecraft/server';

console.warn("§a[Portal Gun V5] Stable Version Loaded!");

// --- CONFIGURATION ---
const PORTAL_ITEM = 'minecraft:blaze_rod';
const PORTAL_NAME = 'Portal Gun';
const MAX_DISTANCE = 64;
const HITBOX_RADIUS = 0.8; 
const COOLDOWN_TICKS = 10; // Prevents jitter
const EXIT_OFFSET = 1.5;   // Pushes you out to prevent wall clipping
const MOMENTUM_MULTIPLIER = 1.3; // Speed boost

// Data Storage
const portalSystem = new Map();

// --- 1. SHOOTING PORTALS ---
world.afterEvents.itemUse.subscribe((event) => {
    const { source: player, itemStack } = event;

    if (itemStack.typeId !== PORTAL_ITEM || itemStack.nameTag !== PORTAL_NAME) return;

    const blockHit = player.getBlockFromViewDirection({ maxDistance: MAX_DISTANCE });

    if (!blockHit) {
        player.sendMessage("§c[Portal] Target out of range.");
        player.playSound("note.bass");
        return;
    }

    const { block, face } = blockHit;
    
    // Center position
    const offset = 0.55; 
    let portalPos = { x: block.x + 0.5, y: block.y + 0.5, z: block.z + 0.5 };

    // Adjust based on face
    if (face === Direction.Up)    portalPos.y += offset;
    else if (face === Direction.Down)  portalPos.y -= offset;
    else if (face === Direction.North) portalPos.z -= offset;
    else if (face === Direction.South) portalPos.z += offset;
    else if (face === Direction.West)  portalPos.x -= offset;
    else if (face === Direction.East)  portalPos.x += offset;

    let pData = portalSystem.get(player.id) || { blue: null, orange: null, cooldown: 0 };

    const newPortal = { 
        location: portalPos, 
        face: face, 
        dimensionId: player.dimension.id 
    };

    if (player.isSneaking) {
        pData.orange = newPortal;
        player.sendMessage("§6[Portal] Orange Portal Set");
        player.playSound("mob.endermen.portal");
    } else {
        pData.blue = newPortal;
        player.sendMessage("§b[Portal] Blue Portal Set");
        player.playSound("mob.endermen.portal");
    }

    portalSystem.set(player.id, pData);
});

// --- 2. PHYSICS LOOP (1 Tick) ---
system.runInterval(() => {
    for (const player of world.getPlayers()) {
        const pData = portalSystem.get(player.id);
        if (!pData) continue;

        if (pData.cooldown > 0) pData.cooldown--;

        // Draw Particles & Check Distance
        if (pData.blue) managePortal(player, pData, 'blue');
        if (pData.orange) managePortal(player, pData, 'orange');
    }
}, 1);

function managePortal(player, pData, color) {
    const portal = pData[color];
    const otherPortal = color === 'blue' ? pData.orange : pData.blue;
    const dimension = world.getDimension(portal.dimensionId);

    // --- A. PARTICLE RING VISUALS ---
    try {
        const particle = color === 'blue' ? "minecraft:blue_flame_particle" : "minecraft:basic_flame_particle";
        drawPortalRing(dimension, portal.location, portal.face, particle);
    } catch (e) {}

    // --- B. TELEPORT CHECK ---
    if (pData.cooldown === 0 && otherPortal) {
        if (player.dimension.id !== portal.dimensionId) return;

        const dx = player.location.x - portal.location.x;
        const dy = player.location.y - portal.location.y;
        const dz = player.location.z - portal.location.z;
        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

        if (dist < HITBOX_RADIUS) {
            performTeleport(player, portal, otherPortal, pData);
        }
    }
}

function drawPortalRing(dimension, center, face, particle) {
    // Draw fewer particles for performance
    if (system.currentTick % 3 !== 0) return;

    const radius = 0.8;
    const steps = 8; 

    for (let i = 0; i < steps; i++) {
        const angle = (i / steps) * Math.PI * 2;
        const offsetX = Math.cos(angle) * radius;
        const offsetZ = Math.sin(angle) * radius;

        let pLoc = { ...center };

        // Rotate ring based on face
        if (face === Direction.Up || face === Direction.Down) {
            pLoc.x += offsetX;
            pLoc.z += offsetZ;
        } else if (face === Direction.North || face === Direction.South) {
            pLoc.x += offsetX;
            pLoc.y += offsetZ;
        } else { // East/West
            pLoc.z += offsetX;
            pLoc.y += offsetZ;
        }

        dimension.spawnParticle(particle, pLoc);
    }
}

function performTeleport(player, entryPortal, exitPortal, pData) {
    pData.cooldown = COOLDOWN_TICKS;

    // --- 1. CALCULATE EXIT POSITION ---
    let exitPos = { ...exitPortal.location };
    let exitNormal = { x: 0, y: 0, z: 0 };

    // Push player 1.5 blocks away from the wall/floor to prevent desync
    if (exitPortal.face === Direction.Up) { exitPos.y += EXIT_OFFSET; exitNormal.y = 1; }
    else if (exitPortal.face === Direction.Down) { exitPos.y -= EXIT_OFFSET + 1.6; exitNormal.y = -1; }
    else if (exitPortal.face === Direction.North) { exitPos.z -= EXIT_OFFSET; exitNormal.z = -1; }
    else if (exitPortal.face === Direction.South) { exitPos.z += EXIT_OFFSET; exitNormal.z = 1; }
    else if (exitPortal.face === Direction.West) { exitPos.x -= EXIT_OFFSET; exitNormal.x = -1; }
    else if (exitPortal.face === Direction.East) { exitPos.x += EXIT_OFFSET; exitNormal.x = 1; }

    // --- 2. CALCULATE ROTATION ---
    const currentRot = player.getRotation();
    
    const getYaw = (face) => {
        if (face === Direction.North) return 180;
        if (face === Direction.South) return 0;
        if (face === Direction.West) return 90;
        if (face === Direction.East) return -90;
        return 0;
    };

    let newYaw = currentRot.y;
    // Only rotate if moving between walls
    if (entryPortal.face !== Direction.Up && entryPortal.face !== Direction.Down &&
        exitPortal.face !== Direction.Up && exitPortal.face !== Direction.Down) {
        const entryYaw = getYaw(entryPortal.face);
        const exitYaw = getYaw(exitPortal.face);
        newYaw = currentRot.y + (exitYaw - entryYaw) + 180;
    }

    // --- 3. CALCULATE VELOCITY ---
    const oldVel = player.getVelocity();
    const speed = Math.sqrt(oldVel.x**2 + oldVel.y**2 + oldVel.z**2);
    // Ensure minimum launch speed so you don't just plop out
    const launchSpeed = Math.max(speed, 0.8) * MOMENTUM_MULTIPLIER;

    const newVel = {
        x: exitNormal.x * launchSpeed,
        y: exitNormal.y * launchSpeed,
        z: exitNormal.z * launchSpeed
    };

    // --- 4. EXECUTE ---
    try {
        const targetDim = world.getDimension(exitPortal.dimensionId);
        
        // A. Teleport
        player.teleport(exitPos, {
            dimension: targetDim,
            rotation: { x: currentRot.x, y: newYaw }
        });

        // B. Apply Velocity (Delayed 1 tick to override server correction)
        system.run(() => {
            if (player.isValid) {
                // Clear any residual fall damage or weird physics
                player.clearVelocity(); 
                player.applyImpulse(newVel);
                player.playSound("mob.shulker.teleport");
            }
        });

    } catch (e) {
        console.warn("Teleport Error: " + e);
    }
}

import { world, system } from '@minecraft/server';

world.afterEvents.entityHitEntity.subscribe((event) => {
    const { damagingEntity, hitEntity } = event;

    if (!damagingEntity || damagingEntity.typeId !== 'minecraft:player') return;
    if (!hitEntity || !hitEntity.isValid) return;

    const player = damagingEntity;
    const inventory = player.getComponent('inventory').container;
    const item = inventory.getItem(player.selectedSlotIndex);

    if (!item || item.nameTag !== "Rogue Dagger") return;

    try {
        const mobLoc = hitEntity.location;
        const playerLoc = player.location;

        const dx = playerLoc.x - mobLoc.x;
        const dz = playerLoc.z - mobLoc.z;
        const currentDist = Math.sqrt(dx * dx + dz * dz);

        if (currentDist > 0.1) {
            const targetDistance = 2.0;
            const scale = targetDistance / currentDist;

            const dest = {
                x: mobLoc.x - (dx * scale),
                y: mobLoc.y,
                z: mobLoc.z - (dz * scale)
            };

            player.teleport(dest, {
                dimension: hitEntity.dimension,
                facingLocation: mobLoc
            });
        }
    } catch (error) {}

    if (hitEntity.getTags().includes("rogue_marked")) return;
    
    hitEntity.addTag("rogue_marked");

    player.onScreenDisplay.setActionBar("§c3");

    system.runTimeout(() => {
        if (hitEntity.isValid) {
            player.onScreenDisplay.setActionBar("§62");
        }
    }, 20);

    system.runTimeout(() => {
        if (hitEntity.isValid) {
            player.onScreenDisplay.setActionBar("§e1");
        }
    }, 40);

    system.runTimeout(() => {
        if (hitEntity.isValid) {
            hitEntity.kill();
            player.onScreenDisplay.setActionBar("§4Executed!");
            player.playSound("random.explode");
        }
    }, 60);
});

import { world, system, EffectTypes, ItemStack, EntityComponentTypes } from "@minecraft/server";

const TARGET_BLOCK_ID = 'c:test'; 
const MAX_DISTANCE_BLOCKS = 2500; 
const HOP_DELAY = 5;
const SAFE_Y_LEVEL = 150;
const DROP_Y_LEVEL = 125;
const SCAN_Y_MIN = 60;
const SCAN_Y_MAX = 80;

const LOOK_AHEAD_CHUNKS = 8;   
const FLOOD_FILL_LIMIT = 300; 

const sessions = new Map();
const STATE_HOPPING = 'hopping';
const STATE_ANALYZING = 'analyzing';
const STATE_CONFIRMING = 'confirming';

world.beforeEvents.chatSend.subscribe((event) => {
    const message = event.message.trim();
    const player = event.sender;

    if (message === "!test") {
        event.cancel = true;
        system.run(() => {
            if (sessions.has(player.id)) return;
            startChunkHopper(player);
        });
    }
    else if (message === "!stop") {
        event.cancel = true;
        system.run(() => cleanup(player));
    }
});

world.afterEvents.itemUse.subscribe((event) => {
    const player = event.source;
    const item = event.itemStack;
    
    if (item.typeId === 'minecraft:nether_star') {
        if (sessions.has(player.id)) return;
        startChunkHopper(player);
        return;
    }

    const session = sessions.get(player.id);
    if (!session || session.state !== STATE_CONFIRMING) return;

    if (item.typeId === 'minecraft:emerald' && item.nameTag === '§aACCEPT') {
        doDropSequence(player, session.foundLoc);
        cleanup(player); 
    } 
    else if (item.typeId === 'minecraft:redstone' && item.nameTag === '§cDECLINE') {
        player.teleport(session.originalLoc);
        cleanup(player);
    }
});

function startChunkHopper(player) {
    const dimension = player.dimension;
    const view = player.getViewDirection();
    const dirX = view.x >= 0 ? 1 : -1;
    const dirZ = view.z >= 0 ? 1 : -1;

    const stepX = 2 * dirX;
    const stepZ = 16 * dirZ;

    const maxHops = Math.ceil(MAX_DISTANCE_BLOCKS / 16);

    let marker = spawnMarker(dimension, player.location);

    const sessionData = {
        intervalId: null,
        marker: marker,
        originalLoc: player.location,
        currentHops: 0,
        stepX: stepX,
        stepZ: stepZ,
        foundLoc: null,
        state: STATE_HOPPING,
        analysisBuffer: [],
        analysisCounter: 0
    };

    const intervalId = system.runInterval(() => {
        if (!player.isValid) {
            cleanup(player);
            return;
        }

        if (!sessionData.marker || !sessionData.marker.isValid) {
            sessionData.marker = spawnMarker(dimension, player.location);
        }

        if (sessionData.currentHops >= maxHops) {
            player.teleport(sessionData.originalLoc);
            cleanup(player);
            return;
        }

        const nextX = sessionData.originalLoc.x + (sessionData.stepX * (sessionData.currentHops + 1));
        const nextZ = sessionData.originalLoc.z + (sessionData.stepZ * (sessionData.currentHops + 1));
        
        const newPos = {
            x: nextX,
            y: SAFE_Y_LEVEL,
            z: nextZ
        };

        try {
            player.addEffect(EffectTypes.get("slow_falling"), 1000, { amplifier: 0, showParticles: false });
            player.addEffect(EffectTypes.get("blindness"), 200, { amplifier: 0, showParticles: false });

            if (sessionData.marker && sessionData.marker.isValid) {
                sessionData.marker.teleport(newPos);
            }
            player.teleport(newPos);
            
            sessionData.currentHops++;

            if (sessionData.state === STATE_HOPPING) {
                if (quincunxCheck(dimension, newPos)) {
                    sessionData.state = STATE_ANALYZING;
                    sessionData.analysisCounter = 0;
                    sessionData.analysisBuffer = [];
                    
                    const score = calculateChunkScore(dimension, newPos);
                    sessionData.analysisBuffer.push({ loc: newPos, score: score });
                }
            }
            
            else if (sessionData.state === STATE_ANALYZING) {
                const score = calculateChunkScore(dimension, newPos);
                sessionData.analysisBuffer.push({ loc: newPos, score: score });
                sessionData.analysisCounter++;

                if (sessionData.analysisCounter >= LOOK_AHEAD_CHUNKS) {
                    let bestChunk = sessionData.analysisBuffer[0];
                    for (const chunkData of sessionData.analysisBuffer) {
                        if (chunkData.score > bestChunk.score) {
                            bestChunk = chunkData;
                        }
                    }

                    const finalSpot = findLargestIslandCenter(dimension, bestChunk.loc);
                    sessionData.foundLoc = finalSpot;
                    initiateConfirmation(player, sessionData);
                }
            }

        } catch (err) {
            console.warn(`[ChunkHopper] Error: ${err}`);
        }

    }, HOP_DELAY);

    sessionData.intervalId = intervalId;
    sessions.set(player.id, sessionData);
}

function spawnMarker(dimension, loc) {
    try {
        const m = dimension.spawnEntity("minecraft:armor_stand", {x: loc.x, y: SAFE_Y_LEVEL, z: loc.z});
        m.nameTag = "Chunk Cursor";
        m.addEffect(EffectTypes.get("invisibility"), 200000, { showParticles: false });
        return m;
    } catch (e) { return null; }
}

function quincunxCheck(dimension, centerPos) {
    const cx = Math.floor(centerPos.x);
    const cz = Math.floor(centerPos.z);
    
    const points = [
        {x: 0, z: 0},
        {x: -7, z: -7}, {x: 7, z: -7},
        {x: -7, z: 7}, {x: 7, z: 7}
    ];

    for (const p of points) {
        for (let y = SCAN_Y_MIN; y <= SCAN_Y_MAX; y += 2) { 
            try {
                const b = dimension.getBlock({x: cx + p.x, y: y, z: cz + p.z});
                if (b && b.typeId === TARGET_BLOCK_ID) return true;
            } catch(e){}
        }
    }
    return false;
}

function calculateChunkScore(dimension, centerPos) {
    let count = 0;
    let ySum = 0;
    let yValues = [];
    const cx = Math.floor(centerPos.x);
    const cz = Math.floor(centerPos.z);
    
    for (let x = -8; x <= 8; x += 2) {
        for (let z = -8; z <= 8; z += 2) {
            for (let y = SCAN_Y_MIN; y <= SCAN_Y_MAX; y++) {
                try {
                    const b = dimension.getBlock({x: cx + x, y: y, z: cz + z});
                    if (b && b.typeId === TARGET_BLOCK_ID) {
                        count++;
                        ySum += y;
                        yValues.push(y);
                    }
                } catch(e){}
            }
        }
    }

    if (count === 0) return -999;

    const meanY = ySum / count;
    let varianceSum = 0;
    for (const y of yValues) {
        varianceSum += Math.pow(y - meanY, 2);
    }
    const variance = varianceSum / count;

    return count - (variance * 2);
}

function findLargestIslandCenter(dimension, centerPos) {
    const cx = Math.floor(centerPos.x);
    const cz = Math.floor(centerPos.z);
    
    let seed = null;
    for (let y = SCAN_Y_MAX; y >= SCAN_Y_MIN; y--) {
        try {
            const b = dimension.getBlock({x: cx, y: y, z: cz});
            if (b && b.typeId === TARGET_BLOCK_ID) {
                seed = {x: cx, y: y, z: cz};
                break;
            }
        } catch(e){}
    }
    
    if (!seed) {
        for (let r = 1; r <= 8; r++) {
            for (let y = SCAN_Y_MAX; y >= SCAN_Y_MIN; y--) {
                try {
                    const b = dimension.getBlock({x: cx + r, y: y, z: cz});
                    if (b && b.typeId === TARGET_BLOCK_ID) { seed = {x: cx+r, y:y, z:cz}; break; }
                } catch(e){}
            }
            if (seed) break;
        }
    }

    if (!seed) return centerPos; 

    const queue = [seed];
    const visited = new Set();
    const islandBlocks = [];
    visited.add(`${seed.x},${seed.y},${seed.z}`);

    let iterations = 0;

    while (queue.length > 0 && iterations < FLOOD_FILL_LIMIT) {
        const current = queue.shift();
        islandBlocks.push(current);
        iterations++;

        const neighbors = [
            {x:1, y:0, z:0}, {x:-1, y:0, z:0},
            {x:0, y:0, z:1}, {x:0, y:0, z:-1},
            {x:0, y:1, z:0}, {x:0, y:-1, z:0}
        ];

        for (const n of neighbors) {
            const nx = current.x + n.x;
            const ny = current.y + n.y;
            const nz = current.z + n.z;
            const key = `${nx},${ny},${nz}`;

            if (!visited.has(key) && ny >= SCAN_Y_MIN && ny <= SCAN_Y_MAX) {
                try {
                    const b = dimension.getBlock({x: nx, y: ny, z: nz});
                    if (b && b.typeId === TARGET_BLOCK_ID) {
                        visited.add(key);
                        queue.push({x: nx, y: ny, z: nz});
                    }
                } catch(e){}
            }
        }
    }

    let totalX = 0;
    let totalZ = 0;
    let maxY = -999;

    for (const b of islandBlocks) {
        totalX += b.x;
        totalZ += b.z;
        if (b.y > maxY) maxY = b.y; 
    }

    const avgX = Math.floor(totalX / islandBlocks.length);
    const avgZ = Math.floor(totalZ / islandBlocks.length);

    let closestBlock = islandBlocks[0];
    let minDst = 999999;

    for (const b of islandBlocks) {
        if (b.y < maxY) continue; 

        const d = Math.pow(b.x - avgX, 2) + Math.pow(b.z - avgZ, 2);
        if (d < minDst) {
            minDst = d;
            closestBlock = b;
        }
    }

    return closestBlock;
}

function initiateConfirmation(player, session) {
    if (session.intervalId) system.clearRun(session.intervalId);
    
    session.state = STATE_CONFIRMING;
    
    player.addEffect(EffectTypes.get("slow_falling"), 600, { amplifier: 0, showParticles: true });
    player.addEffect(EffectTypes.get("blindness"), 600, { amplifier: 0, showParticles: false });

    player.playSound("random.levelup");
    player.sendMessage("§6[!] CHECK YOUR INVENTORY: Hold Emerald to Accept, Redstone to Decline.");

    const inv = player.getComponent(EntityComponentTypes.Inventory).container;
    
    const acceptItem = new ItemStack("minecraft:emerald");
    acceptItem.nameTag = "§aACCEPT";
    
    const declineItem = new ItemStack("minecraft:redstone");
    declineItem.nameTag = "§cDECLINE";

    inv.addItem(acceptItem);
    inv.addItem(declineItem);
}

function doDropSequence(player, targetLoc) {
    player.teleport({ x: targetLoc.x, y: DROP_Y_LEVEL, z: targetLoc.z });
    
    player.addEffect(EffectTypes.get("slow_falling"), 200000, { amplifier: 0, showParticles: true });
    player.addEffect(EffectTypes.get("blindness"), 1200, { amplifier: 0, showParticles: false });

    const inv = player.getComponent(EntityComponentTypes.Inventory).container;
    const bottleItem = new ItemStack("minecraft:glass_bottle", 1);
    bottleItem.nameTag = "§lSlow Fall";
    inv.addItem(bottleItem);
    
    player.sendMessage("§bDropping... Hold the bottle to clear effects on landing.");

    const landingCheckId = system.runInterval(() => {
        if (!player.isValid) {
            system.clearRun(landingCheckId);
            return;
        }

        const blockBelow = player.dimension.getBlock({
            x: Math.floor(player.location.x),
            y: Math.floor(player.location.y - 0.1),
            z: Math.floor(player.location.z)
        });

        if (blockBelow && blockBelow.typeId === TARGET_BLOCK_ID) {
            const invContainer = player.getComponent(EntityComponentTypes.Inventory).container;
            let hasBottle = false;
            let slotIndex = -1;

            for (let i = 0; i < invContainer.size; i++) {
                const item = invContainer.getItem(i);
                if (item && item.typeId === "minecraft:glass_bottle" && item.nameTag === "§lSlow Fall") {
                    hasBottle = true;
                    slotIndex = i;
                    break;
                }
            }

            if (hasBottle) {
                invContainer.setItem(slotIndex, undefined);
                player.removeEffect(EffectTypes.get("slow_falling"));
                player.removeEffect(EffectTypes.get("blindness"));
                player.sendMessage("§aLanded! Effects cleared.");
                system.clearRun(landingCheckId);
            }
        }
    }, 2);
}

function cleanup(player) {
    if (!player || !sessions.has(player.id)) return;

    const session = sessions.get(player.id);
    
    if (session.marker && session.marker.isValid) {
        try { session.marker.remove(); } catch (e) {}
    }
    
    if (session.intervalId) system.clearRun(session.intervalId);

    if (player.isValid) {
        const inv = player.getComponent(EntityComponentTypes.Inventory).container;
        for (let i = 0; i < inv.size; i++) {
            const item = inv.getItem(i);
            if (item && (item.nameTag === "§aACCEPT" || item.nameTag === "§cDECLINE")) {
                inv.setItem(i, undefined);
            }
        }
    }

    sessions.delete(player.id);
}

import { world, system } from '@minecraft/server';

world.afterEvents.entityDie.subscribe((event) => {
    const { deadEntity, damageSource } = event;

    if (deadEntity.typeId !== 'minecraft:player') return;

    const killer = damageSource.damagingEntity;
    if (!killer || killer.typeId !== 'minecraft:player') return;

    const inventory = killer.getComponent('inventory')?.container;
    if (!inventory) return;

    const heldItem = inventory.getItem(killer.selectedSlotIndex);

    if (heldItem && heldItem.typeId === 'minecraft:diamond_sword') {
        system.run(() => {
            try {
                deadEntity.runCommand('gamemode spectator');
            } catch (error) {
                console.warn(`Error setting gamemode: ${error}`);
            }
        });
    }
});

import { world } from '@minecraft/server';

world.afterEvents.entityHitEntity.subscribe((event) => {
    const { damagingEntity, hitEntity } = event;

    if (damagingEntity.typeId !== 'minecraft:player') return;

    const inventory = damagingEntity.getComponent('inventory')?.container;
    if (!inventory) return;

    const item = inventory.getItem(damagingEntity.selectedSlotIndex);

    if (item && item.typeId === 'minecraft:diamond_sword') {
        const playerLoc = damagingEntity.location;
        const targetLoc = hitEntity.location;

        const dx = targetLoc.x - playerLoc.x;
        const dz = targetLoc.z - playerLoc.z;
        const dist = Math.sqrt(dx * dx + dz * dz) || 1;

        const strength = 4.5;
        const vertical = 0.8;

        hitEntity.applyImpulse({
            x: (dx / dist) * strength,
            y: vertical,
            z: (dz / dist) * strength
        });
    }
});

import { world, system, EntityComponentTypes } from '@minecraft/server';

// --- CONFIGURATION ---
const WAND_ITEM = 'minecraft:stick';
const WAND_NAME = 'Moon Stick';
const RANGE = 20; // How far the wand reaches
const DAMAGE_AMOUNT = 10;
// ---------------------

world.afterEvents.itemUse.subscribe((event) => {
    const { source: player, itemStack } = event;

    // 1. Check Item
    if (itemStack.typeId !== WAND_ITEM || itemStack.nameTag !== WAND_NAME) return;

    const dimension = player.dimension;
    const headLoc = player.getHeadLocation();

    // 2. Raycast: Check what entity the player is looking at
    // getEntitiesFromViewDirection returns an array, we take the first one [0]
    const entityHitResult = player.getEntitiesFromViewDirection({ maxDistance: RANGE })[0];

    // Calculate where the "Beam" ends (either the entity, a block, or max range)
    let targetLoc;
    let targetEntity = null;

    if (entityHitResult) {
        targetEntity = entityHitResult.entity;
        targetLoc = targetEntity.location;
        // Adjust target loc to be center of body roughly
        targetLoc.y += 0.5; 
    } else {
        // If no entity, check for blocks so the beam hits the wall
        const blockHitResult = player.getBlockFromViewDirection({ maxDistance: RANGE });
        if (blockHitResult) {
            targetLoc = blockHitResult.block.location;
        } else {
            // If hitting nothing (sky), just calculate a point in front
            const view = player.getViewDirection();
            targetLoc = {
                x: headLoc.x + (view.x * RANGE),
                y: headLoc.y + (view.y * RANGE),
                z: headLoc.z + (view.z * RANGE)
            };
        }
    }

    // 3. Visuals: Draw the Particle Beam
    drawParticleBeam(dimension, headLoc, targetLoc);
    dimension.playSound('random.bow', headLoc, { pitch: 0.5 });

    // 4. Apply Magic if we hit an entity
    if (targetEntity) {
        applyMoonMagic(targetEntity);
    }
});

// --- HELPER: Draw particles from A to B ---
function drawParticleBeam(dimension, start, end) {
    // Calculate distance
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const dz = end.z - start.z;
    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
    
    const steps = Math.ceil(distance * 2); // 2 particles per block
    const stepX = dx / steps;
    const stepY = dy / steps;
    const stepZ = dz / steps;

    for (let i = 0; i < steps; i++) {
        const pos = {
            x: start.x + (stepX * i),
            y: start.y + (stepY * i) - 0.2, // Lower slightly to come from hand/chest
            z: start.z + (stepZ * i)
        };
        // "Moon" particles
        dimension.spawnParticle("minecraft:endrod", pos);
    }
}

// --- HELPER: Damage or Heal ---
function applyMoonMagic(target) {
    const dim = target.dimension;
    const loc = target.location;

    // Visual impact
    dim.spawnParticle('minecraft:heart_particle', { x: loc.x, y: loc.y + 1, z: loc.z });
    dim.spawnParticle('minecraft:huge_explosion_emitter', loc);

    // Check Family
    const familyComp = target.getComponent('minecraft:type_family');
    let isBadGuy = false;

    if (familyComp) {
        const families = familyComp.getTypeFamilies();
        if (families.includes('monster') || families.includes('undead')) {
            isBadGuy = true;
        }
    }

    if (isBadGuy) {
        // HURT
        target.applyDamage(DAMAGE_AMOUNT, { cause: 'magic' });
        dim.playSound('random.explode', loc, { pitch: 2.0 });
    } else {
        // HEAL
        const healthComp = target.getComponent(EntityComponentTypes.Health);
        if (healthComp) {
            healthComp.setCurrentValue(healthComp.effectiveMax);
            dim.playSound('random.levelup', loc, { pitch: 2.0 });
        }
    }
}

import { world, system } from '@minecraft/server';

world.afterEvents.entityHitEntity.subscribe((event) => {
    const { damagingEntity, hitEntity } = event;

    if (damagingEntity.typeId === 'minecraft:iron_golem') {
        if (hitEntity.typeId === 'minecraft:zombie') {
            const dimension = hitEntity.dimension;
            const location = hitEntity.location;

            system.run(() => {
                try {
                    damagingEntity.remove();
                } catch (e) {}

                try {
                    hitEntity.remove();
                } catch (e) {}

                dimension.spawnEntity('minecraft:iron_golem', location);
            });
        }
    }
});

import { world, system, BlockPermutation } from '@minecraft/server';
import { ModalFormData, ActionFormData } from '@minecraft/server-ui';

// --- CONFIGURATION ---
const WAND_ITEM = 'minecraft:stick';
const WAND_NAME = 'Grow Tree';

// --- PRESETS ---
const PRESETS = [
    { name: "Custom (Use Settings)", axiom: "F", rule: "F" }, 
    { name: "Gnarly Oak", axiom: "F", rule: "F[+F]F[-F][&F][^F]", angle: 25, iter: 3, gravity: 60, decay: 90, leafStyle: 6, wobble: 30 },
    { name: "Weeping Willow", axiom: "F", rule: "FF[+F][-F][&F][^F]", angle: 15, iter: 4, gravity: 85, decay: 85, leafStyle: 1, wobble: 10 },
    { name: "Ancient Pine", axiom: "F", rule: "F[+F][-F][&F][^F]", angle: 35, iter: 4, gravity: 35, decay: 80, leafStyle: 2, wobble: 5 },
    { name: "Sakura (Cherry)", axiom: "F", rule: "F[+F]F[-F][&F]", angle: 30, iter: 4, gravity: 55, decay: 90, leafStyle: 4, wobble: 15 },
    { name: "Giant Mushroom", axiom: "F", rule: "F[+F][-F][&F][^F]", angle: 45, iter: 3, gravity: 50, decay: 80, leafStyle: 3, wobble: 0 },
    { name: "Fractal Fern", axiom: "X", rule: "F+[[X]-X]-F[-FX]+X", angle: 25, iter: 4, gravity: 50, decay: 100, leafStyle: 0, wobble: 0 },
    { name: "Alien Helix", axiom: "F", rule: "F[+F]F[-F]", angle: 20, iter: 5, gravity: 50, decay: 100, leafStyle: 0, wobble: 0 }
];

const TREE_PALETTES = {
    "Oak": { log: "minecraft:oak_log", wood: "minecraft:oak_wood", leaf: "minecraft:oak_leaves" },
    "Spruce": { log: "minecraft:spruce_log", wood: "minecraft:spruce_wood", leaf: "minecraft:spruce_leaves" },
    "Birch": { log: "minecraft:birch_log", wood: "minecraft:birch_wood", leaf: "minecraft:birch_leaves" },
    "Jungle": { log: "minecraft:jungle_log", wood: "minecraft:jungle_wood", leaf: "minecraft:jungle_leaves" },
    "Acacia": { log: "minecraft:acacia_log", wood: "minecraft:acacia_wood", leaf: "minecraft:acacia_leaves" },
    "Dark Oak": { log: "minecraft:dark_oak_log", wood: "minecraft:dark_oak_wood", leaf: "minecraft:dark_oak_leaves" },
    "Cherry": { log: "minecraft:cherry_log", wood: "minecraft:cherry_wood", leaf: "minecraft:cherry_leaves" },
    "Mangrove": { log: "minecraft:mangrove_log", wood: "minecraft:mangrove_wood", leaf: "minecraft:mangrove_leaves" }
};
const PALETTE_KEYS = Object.keys(TREE_PALETTES);
const LEAF_STYLES = ["Cloud (Standard)", "Weeping (Vines)", "Conical (Pine)", "Hemisphere (Mushroom)", "Blossom (Falling)", "Sparse (Dead)", "Fractal Noise (Realistic)"];

// --- MATH ALGORITHMS ---

const toRad = (deg) => deg * (Math.PI / 180);

function rotateVector(v, k, theta) {
    const cosTheta = Math.cos(theta);
    const sinTheta = Math.sin(theta);
    const crossX = k.y * v.z - k.z * v.y;
    const crossY = k.z * v.x - k.x * v.z;
    const crossZ = k.x * v.y - k.y * v.x;
    const dot = k.x * v.x + k.y * v.y + k.z * v.z;
    return {
        x: v.x * cosTheta + crossX * sinTheta + k.x * dot * (1 - cosTheta),
        y: v.y * cosTheta + crossY * sinTheta + k.y * dot * (1 - cosTheta),
        z: v.z * cosTheta + crossZ * sinTheta + k.z * dot * (1 - cosTheta)
    };
}

function normalize(v) {
    const len = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
    if (len === 0) return {x:0, y:1, z:0};
    return { x: v.x/len, y: v.y/len, z: v.z/len };
}

function pseudoNoise(x, y, z) {
    const sin = Math.sin(x * 12.9898 + y * 78.233 + z * 37.719);
    return sin - Math.floor(sin);
}

// --- L-SYSTEM LOGIC ---

function generateString(axiom, ruleF, iterations) {
    let currentString = axiom;
    const ruleSimpleF = "FF"; 
    const ruleX = ruleF; // If using X, the input rule applies to X

    for (let i = 0; i < iterations; i++) {
        let nextString = "";
        for (const char of currentString) {
            if (char === "F") {
                // If the rule is meant for X, F just grows
                if (ruleF.includes("X")) nextString += ruleSimpleF; 
                else nextString += ruleF;
            }
            else if (char === "X") nextString += ruleX;
            else nextString += char;
        }
        currentString = nextString;
    }
    return currentString;
}

// --- ASYNC BUILDER ---

function* buildTreeJob(dimension, startLocation, instructionString, config, palette) {
    let pos = { x: startLocation.x, y: startLocation.y, z: startLocation.z };
    let dir = { x: 0, y: 1, z: 0 }; 
    const stack = [];
    const angleRad = toRad(config.angle);
    const placedHistory = new Set();
    let blocksPlacedThisTick = 0;
    
    // FIX: Convert Integer Sliders back to Floats
    let currentStep = config.stepSize / 10.0; 
    const decayFactor = config.decay / 100.0;
    const gravityFactor = (config.gravity - 50) / 50.0; 
    const wobbleFactor = config.wobble / 200.0;

    // --- BLOCK PLACEMENT ---
    const setBlock = (x, y, z, type, directionVector = null, isJoint = false) => {
        if (y > startLocation.y + config.maxHeight) return false;
        if (y < -64 || y > 319) return false;

        const bx = Math.floor(x), by = Math.floor(y), bz = Math.floor(z);
        const key = `${bx},${by},${bz}`;
        
        if (!placedHistory.has(key)) {
            try {
                const block = dimension.getBlock({x: bx, y: by, z: bz});
                if (block && (block.isAir || block.typeId.includes("plant") || block.typeId.includes("grass") || block.typeId.includes("leaves"))) {
                    
                    if (isJoint && palette.wood) {
                        block.setType(palette.wood);
                    }
                    else if (directionVector && type.includes("_log")) {
                        const absX = Math.abs(directionVector.x);
                        const absY = Math.abs(directionVector.y);
                        const absZ = Math.abs(directionVector.z);
                        
                        let axis = "y";
                        if (absX > absY * 1.2 && absX > absZ) axis = "x";
                        else if (absZ > absY * 1.2 && absZ > absX) axis = "z";

                        const basePerm = BlockPermutation.resolve(type);
                        const finalPerm = basePerm.withState("pillar_axis", axis);
                        block.setPermutation(finalPerm);
                    } else {
                        block.setType(type);
                    }

                    placedHistory.add(key);
                    return true;
                }
            } catch (e) {}
        }
        return false;
    };

    // --- LEAF ALGORITHMS ---
    const leafCloud = (center) => {
        const r = 2.5;
        for (let x = -r; x <= r; x++) for (let y = -r; y <= r; y++) for (let z = -r; z <= r; z++) {
            if (Math.random() < (1 - (Math.sqrt(x*x+y*y+z*z)/3.0))) setBlock(center.x+x, center.y+y, center.z+z, palette.leaf);
        }
    };
    const leafWeeping = (center) => {
        const length = Math.floor(Math.random() * 5) + 3;
        setBlock(center.x, center.y, center.z, palette.leaf);
        for (let i = 1; i <= length; i++) {
            setBlock(center.x, center.y - i, center.z, palette.leaf);
            if (Math.random() > 0.6) setBlock(center.x+1, center.y - i, center.z, palette.leaf);
            if (Math.random() > 0.6) setBlock(center.x, center.y - i, center.z+1, palette.leaf);
        }
    };
    const leafConical = (center) => {
        for(let x=-1; x<=1; x++) for(let z=-1; z<=1; z++) setBlock(center.x+x, center.y, center.z+z, palette.leaf);
        setBlock(center.x, center.y+1, center.z, palette.leaf);
        setBlock(center.x, center.y+2, center.z, palette.leaf);
    };
    const leafHemisphere = (center) => {
        const r = 3;
        for (let x = -r; x <= r; x++) for (let y = 0; y <= r; y++) for (let z = -r; z <= r; z++) {
            if (Math.sqrt(x*x + y*y + z*z) <= r) setBlock(center.x+x, center.y+y, center.z+z, palette.leaf);
        }
        for (let x = -r; x <= r; x++) for (let z = -r; z <= r; z++) {
            if (Math.sqrt(x*x + z*z) <= r) setBlock(center.x+x, center.y, center.z+z, palette.leaf);
        }
    };
    const leafBlossom = (center) => {
        leafCloud(center);
        for(let i=1; i<=3; i++) if(Math.random() > 0.7) setBlock(center.x, center.y-i, center.z, palette.leaf);
    };
    const leafSparse = (center) => {
        if(Math.random() > 0.8) setBlock(center.x, center.y, center.z, palette.leaf);
    };
    const leafFractal = (center) => {
        const r = 3;
        for (let x = -r; x <= r; x++) for (let y = -r; y <= r; y++) for (let z = -r; z <= r; z++) {
            const dist = Math.sqrt(x*x + y*y + z*z);
            const noise = pseudoNoise(center.x+x, center.y+y, center.z+z);
            if (dist < r && noise > 0.4) setBlock(center.x+x, center.y+y, center.z+z, palette.leaf);
        }
    };

    // --- LINE DRAWING ---
    const drawLine = (start, end, type, direction, depth) => {
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const dz = end.z - start.z;
        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
        const steps = Math.ceil(distance * 1.5); 

        let placed = 0;
        let thickness = 0;
        if (config.useThickness) {
            if (depth === 0) thickness = 1; 
            else if (depth === 1) thickness = 0; 
        }

        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            
            let wx = 0, wy = 0, wz = 0;
            if (wobbleFactor > 0) {
                wx = (pseudoNoise(start.x + i, start.y, start.z) - 0.5) * wobbleFactor;
                wy = (pseudoNoise(start.x, start.y + i, start.z) - 0.5) * wobbleFactor;
                wz = (pseudoNoise(start.x, start.y, start.z + i) - 0.5) * wobbleFactor;
            }

            const cx = start.x + (dx * t) + wx;
            const cy = start.y + (dy * t) + wy;
            const cz = start.z + (dz * t) + wz;
            
            const localDir = { x: direction.x + wx, y: direction.y + wy, z: direction.z + wz };

            if (setBlock(cx, cy, cz, type, localDir)) placed++;

            if (thickness >= 1) {
                setBlock(cx+1, cy, cz, type, localDir);
                setBlock(cx-1, cy, cz, type, localDir);
                setBlock(cx, cy, cz+1, type, localDir);
                setBlock(cx, cy, cz-1, type, localDir);
            }
        }
        return placed;
    };

    // --- MAIN LOOP ---
    if (palette.wood) {
        for(let x=-1; x<=1; x++) for(let z=-1; z<=1; z++) {
            setBlock(startLocation.x+x, startLocation.y, startLocation.z+z, palette.wood, null, true);
            setBlock(startLocation.x+x, startLocation.y-1, startLocation.z+z, palette.wood, null, true);
        }
    }

    for (let i = 0; i < instructionString.length; i++) {
        const char = instructionString[i];

        if (char === "F") {
            dir.y -= gravityFactor * 0.2; 
            dir = normalize(dir);

            const endPos = {
                x: pos.x + (dir.x * currentStep),
                y: pos.y + (dir.y * currentStep),
                z: pos.z + (dir.z * currentStep)
            };
            
            blocksPlacedThisTick += drawLine(pos, endPos, palette.log, dir, stack.length);
            pos = endPos;
        } 
        else if (char === "[") {
            setBlock(pos.x, pos.y, pos.z, palette.wood, null, true);
            stack.push({ pos: { ...pos }, dir: { ...dir }, step: currentStep });
            currentStep *= decayFactor;
        } 
        else if (char === "]") {
            if (config.leafStyle === 1) leafWeeping(pos);
            else if (config.leafStyle === 2) leafConical(pos);
            else if (config.leafStyle === 3) leafHemisphere(pos);
            else if (config.leafStyle === 4) leafBlossom(pos);
            else if (config.leafStyle === 5) leafSparse(pos);
            else if (config.leafStyle === 6) leafFractal(pos);
            else leafCloud(pos);

            blocksPlacedThisTick += 5;

            if (stack.length > 0) {
                const state = stack.pop();
                pos = state.pos;
                dir = state.dir;
                currentStep = state.step; 
            }
        } 
        else {
            const noise = (Math.random() - 0.5) * 0.2; 
            const finalAngle = angleRad + noise;

            if (char === "+") dir = rotateVector(dir, {x:0, y:1, z:0}, finalAngle);
            else if (char === "-") dir = rotateVector(dir, {x:0, y:1, z:0}, -finalAngle);
            else if (char === "&") dir = rotateVector(dir, {x:1, y:0, z:0}, finalAngle);
            else if (char === "^") dir = rotateVector(dir, {x:1, y:0, z:0}, -finalAngle);
            else if (char === "/") dir = rotateVector(dir, {x:0, y:0, z:1}, finalAngle);
            else if (char === "*") dir = rotateVector(dir, {x:0, y:0, z:1}, -finalAngle);
            
            dir = normalize(dir);
        }

        if (blocksPlacedThisTick > 100) {
            blocksPlacedThisTick = 0;
            yield; 
        }
    }
}

// --- WIKI SYSTEM ---
async function showWiki(player) {
    const wiki = new ActionFormData()
        .title("The Architect's Wiki")
        .body("Select a chapter to learn the secrets of tree generation.")
        .button("Chapter 1: The Basics")
        .button("Chapter 2: Advanced Symbols")
        .button("Chapter 3: Pro Tips");

    const response = await wiki.show(player);
    if (response.canceled) return;

    if (response.selection === 0) {
        const ch1 = new ActionFormData()
            .title("Chapter 1: Basics")
            .body("§lThe Alphabet§r\n\n§bF§r: Grow Forward.\n§b[§r: Start Branch (Save Spot).\n§b]§r: End Branch (Go Back).\n§b+ / -§r: Turn Left / Right.\n§b& / ^§r: Pitch Down / Up.\n\n§lExample:§r\nF[+F][-F]\nGrows up, branches left, branches right.")
            .button("Back");
        await ch1.show(player);
    } 
    else if (response.selection === 1) {
        const ch2 = new ActionFormData()
            .title("Chapter 2: Advanced")
            .body("§lHidden Symbols§r\n\n§b/ / *§r: Roll (Twist) the branch. Essential for 3D trees.\n§bX§r: The 'Fractal' variable. Use this to make Ferns. If used, 'F' just draws lines, and 'X' becomes the branch point.\n\n§lThe Empty Bracket Trick§r\n§b[ ]§r: Creates a 'Ghost Branch'. It immediately ends, spawning leaves directly on the trunk. Great for vines!")
            .button("Back");
        await ch2.show(player);
    }
    else if (response.selection === 2) {
        const ch3 = new ActionFormData()
            .title("Chapter 3: Pro Tips")
            .body("§lGravity§r\n50 is Neutral. <50 goes UP. >50 goes DOWN.\n\n§lWobble§r\nAdds noise to lines. Use low angles (10-15) with High Wobble for lightning/root effects.\n\n§lDecay§r\nSet to 90-95 for tall trees. Set to 60 for tiny Bonsai trees.")
            .button("Back");
        await ch3.show(player);
    }
}

// --- EVENT HANDLER ---

world.afterEvents.playerBreakBlock.subscribe(async (event) => {
    const { player, block, itemStackBeforeBreak } = event;

    if (!itemStackBeforeBreak || itemStackBeforeBreak.typeId !== WAND_ITEM || itemStackBeforeBreak.nameTag !== WAND_NAME) {
        return;
    }

    const presetNames = PRESETS.map(p => p.name);

    const form = new ModalFormData()
        .title("Grow Tree V10")
        .dropdown("Tree Preset", presetNames, { defaultValueIndex: 1 }) 
        .dropdown("Wood Type", PALETTE_KEYS, { defaultValueIndex: 0 })
        .toggle("📖 Open Guide / Wiki", { defaultValue: false }) // NEW WIKI BUTTON
        .toggle("Use Custom Settings?", { defaultValue: false }) 
        // Custom Settings
        .dropdown("Leaf Style", LEAF_STYLES, { defaultValueIndex: 0 })
        .toggle("Enable Thickness?", { defaultValue: true })
        .slider("Gravity (0=Up, 50=None, 100=Down)", 0, 100, { valueStep: 5, defaultValue: 60 }) 
        .slider("Wobble (Gnarliness)", 0, 100, { valueStep: 5, defaultValue: 10 }) 
        .slider("Decay % (90 = Standard)", 50, 99, { valueStep: 1, defaultValue: 90 }) // FIXED SLIDER
        .slider("Max Height Limit", 10, 100, { valueStep: 1, defaultValue: 50 })
        .textField("Axiom", "F", { defaultValue: "F" })
        .textField("Rule", "F[+F]F[-F]", { defaultValue: "F[+F]F[-F][&F][^F]" })
        .slider("Iterations", 1, 5, { valueStep: 1, defaultValue: 3 })
        .slider("Angle", 10, 90, { valueStep: 1, defaultValue: 25 })
        .slider("Step Size (x10)", 10, 50, { valueStep: 1, defaultValue: 20 }); // FIXED SLIDER

    system.run(async () => {
        const response = await form.show(player);

        if (response.canceled) return;

        const [presetIndex, paletteIndex, openWiki, useCustom, custLeaf, custThick, custGrav, custWobble, custDecay, custMaxH, custAxiom, custRule, custIter, custAngle, custStep] = response.formValues;
        
        // CHECK WIKI FIRST
        if (openWiki) {
            await showWiki(player);
            return;
        }

        const selectedPalette = TREE_PALETTES[PALETTE_KEYS[paletteIndex]];
        let config = {};
        let axiom = "";
        let rule = "";

        if (useCustom || presetIndex === 0) {
            config = { 
                angle: custAngle, 
                stepSize: custStep, 
                gravity: custGrav, 
                decay: custDecay, 
                leafStyle: custLeaf,
                useThickness: custThick,
                wobble: custWobble,
                maxHeight: custMaxH
            };
            axiom = custAxiom;
            rule = custRule;
            config.iterations = custIter; 
        } else {
            const p = PRESETS[presetIndex];
            config = { 
                angle: p.angle, 
                stepSize: custStep, 
                gravity: p.gravity !== undefined ? p.gravity : 50,
                decay: p.decay !== undefined ? p.decay : 90,
                leafStyle: p.leafStyle !== undefined ? p.leafStyle : 0,
                useThickness: p.thickness !== undefined ? p.thickness : true,
                wobble: p.wobble !== undefined ? p.wobble : 0,
                maxHeight: 60 
            }; 
            axiom = p.axiom;
            rule = p.rule;
            config.iterations = p.iter;
        }

        player.sendMessage(`§aGrowing ${useCustom ? "Custom" : PRESETS[presetIndex].name} Tree...`);

        const instructions = generateString(axiom, rule, config.iterations);
        
        if (instructions.length > 80000) {
            player.sendMessage("§cTree too big! Reducing complexity.");
            return;
        }

        system.runJob(buildTreeJob(player.dimension, block.location, instructions, config, selectedPalette));
    });
});

import { world, system, EffectTypes } from '@minecraft/server';

const TRIGGER_ITEM = 'minecraft:nether_star';
const TARGET_BIOME = 'ps:triasaic';
const SEARCH_RANGE = 10000;

world.afterEvents.itemUse.subscribe((event) => {
    const { source: player, itemStack } = event;

    if (itemStack.typeId !== TRIGGER_ITEM) return;

    const dimension = player.dimension;

    system.run(() => {
        try {
            const foundLocation = dimension.findClosestBiome(
                player.location,
                TARGET_BIOME,
                {
                    boundingBox: {
                        min: { x: player.location.x - SEARCH_RANGE, y: -64, z: player.location.z - SEARCH_RANGE },
                        max: { x: player.location.x + SEARCH_RANGE, y: 320, z: player.location.z + SEARCH_RANGE }
                    }
                }
            );

            if (foundLocation) {
                player.addEffect(EffectTypes.get("blindness"), 2000, { amplifier: 0, showParticles: false });
                player.addEffect(EffectTypes.get("resistance"), 2000, { amplifier: 255, showParticles: false });
                player.teleport({ x: foundLocation.x, y: 319, z: foundLocation.z });

                const loadCheckInterval = system.runInterval(() => {
                    try {
                        const topBlock = dimension.getTopmostBlock({ x: foundLocation.x, z: foundLocation.z });

                        if (topBlock) {
                            const groundY = topBlock.location.y + 1;
                            
                            player.teleport({ x: foundLocation.x, y: groundY, z: foundLocation.z });
                            
                            if (topBlock.typeId === 'ps:triassic_dirt') {
                                player.removeEffect(EffectTypes.get("blindness"));
                                player.removeEffect(EffectTypes.get("resistance"));
                            }

                            system.clearRun(loadCheckInterval);
                        }
                    } catch (e) {
                    }
                }, 5);
            } else {
                console.warn(`Biome ${TARGET_BIOME} not found within range.`);
            }

        } catch (error) {
            console.warn(error);
        }
    });
});

import { world, system } from '@minecraft/server';

const DASH_ITEM = 'minecraft:stick';
const DASH_POWER = 1.5;
const VERTICAL_BOOST = 0.5;
const COOLDOWN_TICKS = 60;
const TRAIL_DURATION = 15;

const cooldowns = new Map();
const trailTimers = new Map();

world.afterEvents.itemUse.subscribe((event) => {
    const { source: player, itemStack } = event;

    if (itemStack.typeId !== DASH_ITEM) return;

    const currentTick = system.currentTick;

    if (cooldowns.has(player.id) && cooldowns.get(player.id) > currentTick) {
        const remaining = Math.ceil((cooldowns.get(player.id) - currentTick) / 20);
        player.onScreenDisplay.setActionBar(`§cCooldown: ${remaining}s`);
        return;
    }

    const viewDir = player.getViewDirection();

    player.applyImpulse({
        x: viewDir.x * DASH_POWER,
        y: VERTICAL_BOOST,
        z: viewDir.z * DASH_POWER
    });

    player.playSound("mob.ghast.fireball");
    
    cooldowns.set(player.id, currentTick + COOLDOWN_TICKS);
    trailTimers.set(player.id, currentTick + TRAIL_DURATION);
});

system.runInterval(() => {
    const currentTick = system.currentTick;

    for (const player of world.getPlayers()) {
        if (trailTimers.has(player.id)) {
            if (trailTimers.get(player.id) > currentTick) {
                try {
                    const loc = player.location;
                    player.dimension.spawnParticle("minecraft:endrod", {
                        x: loc.x,
                        y: loc.y + 1.0,
                        z: loc.z
                    });
                } catch (e) {}
            } else {
                trailTimers.delete(player.id);
            }
        }
    }
});

import { world, system } from '@minecraft/server';

const DASH_ITEM = 'minecraft:stick';
const DASH_POWER = 1.5;
const VERTICAL_BOOST = 0.5;
const COOLDOWN_TICKS = 60;
const TRAIL_DURATION = 15;

const cooldowns = new Map();
const trailTimers = new Map();

world.afterEvents.itemUse.subscribe((event) => {
    const { source: player, itemStack } = event;

    if (itemStack.typeId !== DASH_ITEM) return;

    const currentTick = system.currentTick;

    if (cooldowns.has(player.id) && cooldowns.get(player.id) > currentTick) {
        const remaining = Math.ceil((cooldowns.get(player.id) - currentTick) / 20);
        player.onScreenDisplay.setActionBar(`§cCooldown: ${remaining}s`);
        return;
    }

    const viewDir = player.getViewDirection();

    player.applyImpulse({
        x: viewDir.x * DASH_POWER,
        y: VERTICAL_BOOST,
        z: viewDir.z * DASH_POWER
    });

    player.playSound("mob.ghast.fireball");
    
    cooldowns.set(player.id, currentTick + COOLDOWN_TICKS);
    trailTimers.set(player.id, currentTick + TRAIL_DURATION);
});

system.runInterval(() => {
    const currentTick = system.currentTick;

    for (const player of world.getPlayers()) {
        if (trailTimers.has(player.id)) {
            if (trailTimers.get(player.id) > currentTick) {
                try {
                    const loc = player.location;
                    player.dimension.spawnParticle("minecraft:endrod", {
                        x: loc.x,
                        y: loc.y + 1.0,
                        z: loc.z
                    });
                } catch (e) {}
            } else {
                trailTimers.delete(player.id);
            }
        }
    }
});

import { world, system, EntityComponentTypes, EquipmentSlot, EffectTypes } from '@minecraft/server';

// --- CONFIGURATION ---
const PARRY_WINDOW = 8;       // 0.4 seconds (8 ticks)
const PARRY_COOLDOWN = 30;    // 1.5 seconds
const DASH_STRENGTH = 1.2; 
const SHIELD_ITEM = 'minecraft:shield';

// Data Storage
const parryState = new Map();   // <PlayerID, ExpiryTick>
const cooldowns = new Map();    // <PlayerID, CooldownTick>
const wasSneaking = new Map();  // <PlayerID, Boolean>

// 1. DETECT SNEAK (TRIGGER PARRY)
system.runInterval(() => {
    const currentTick = system.currentTick;

    for (const player of world.getPlayers()) {
        const isSneaking = player.isSneaking;
        const previousSneak = wasSneaking.get(player.id) || false;

        // Detect "Press" (False -> True)
        if (isSneaking && !previousSneak) {
            
            // Check Cooldown
            if (!cooldowns.has(player.id) || currentTick > cooldowns.get(player.id)) {
                
                // Check Offhand Shield
                const equippable = player.getComponent(EntityComponentTypes.Equippable);
                const offhand = equippable.getEquipment(EquipmentSlot.Offhand);

                if (offhand && offhand.typeId === SHIELD_ITEM) {
                    // ACTIVATE PARRY
                    parryState.set(player.id, currentTick + PARRY_WINDOW);
                    cooldowns.set(player.id, currentTick + PARRY_COOLDOWN);
                    
                    // GIVE IMMUNITY (Resistance 255 makes you take 0 damage)
                    // We give it for 8 ticks (0.4s)
                    player.addEffect(EffectTypes.get("resistance"), PARRY_WINDOW, { amplifier: 255, showParticles: false });
                    
                    // Visual Indicator
                    player.playSound("armor.equip_chain"); 
                }
            }
        }

        // Update state for next tick
        wasSneaking.set(player.id, isSneaking);
    }
});

// 2. HANDLE COUNTER-ATTACK (Using afterEvents)
world.afterEvents.entityHurt.subscribe((event) => {
    const { hurtEntity, damageSource } = event;

    if (hurtEntity.typeId !== 'minecraft:player') return;

    // Check if Player is in Parry Window
    if (parryState.has(hurtEntity.id)) {
        const expiry = parryState.get(hurtEntity.id);
        
        if (system.currentTick <= expiry) {
            // --- SUCCESSFUL PARRY ---
            // Note: Damage was already reduced to 0 by Resistance, 
            // so we just need to do the Visuals and Counter-Attack.

            handleParryEffects(hurtEntity, damageSource);
            
            // Remove parry state (consumes the parry)
            parryState.delete(hurtEntity.id);
            
            // Optional: Remove Resistance immediately if you want them vulnerable again instantly
            hurtEntity.removeEffect(EffectTypes.get("resistance"));
        }
    }
});

function handleParryEffects(player, source) {
    const attacker = source.damagingEntity;
    
    // Visuals
    player.playSound("mob.enderdragon.flap"); 
    player.dimension.spawnParticle("minecraft:knockback_roar_particle", player.location);

    // LOGIC: Distinguish between Projectile vs Melee
    if (source.cause === 'projectile') {
        // --- DEFLECT (Ranged) ---
        if (attacker && attacker.isValid) {
            player.playSound("random.bow");
            player.dimension.spawnParticle("minecraft:electric_spark", player.getHeadLocation());
            
            // Return Fire
            const pLoc = player.getHeadLocation();
            const aLoc = attacker.getHeadLocation();
            const dx = aLoc.x - pLoc.x;
            const dy = aLoc.y - pLoc.y;
            const dz = aLoc.z - pLoc.z;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            const vel = {
                x: (dx / dist) * 3.0,
                y: (dy / dist) * 3.0,
                z: (dz / dist) * 3.0
            };

            const arrow = player.dimension.spawnEntity("minecraft:arrow", {
                x: pLoc.x + (dx/dist), 
                y: pLoc.y + (dy/dist), 
                z: pLoc.z + (dz/dist)
            });
            
            const proj = arrow.getComponent("minecraft:projectile");
            if (proj) proj.shoot(vel);
            else arrow.applyImpulse(vel);
        }
    } else {
        // --- DASH (Melee) ---
        const viewDir = player.getViewDirection();
        player.applyImpulse({
            x: -viewDir.x * DASH_STRENGTH,
            y: 0.3,
            z: -viewDir.z * DASH_STRENGTH
        });
    }
}

// Cleanup Loop
system.runInterval(() => {
    const current = system.currentTick;
    for (const [id, time] of parryState) {
        if (current > time) parryState.delete(id);
    }
}, 20);

import { world, system, EntityComponentTypes, EquipmentSlot, GameMode } from '@minecraft/server';

// --- CONFIGURATION ---
const FLIGHT_ARMOR_ID = 'minecraft:netherite_chestplate'; // Change this to your custom armor ID
const FLIGHT_TAG = "has_flight_ability";

system.runInterval(() => {
    for (const player of world.getPlayers()) {
        // 1. Safety Check: Ignore Creative/Spectator players
        // We don't want to accidentally disable their flight if they take off the armor.
        const gamemode = player.getGameMode();
        if (gamemode === GameMode.creative || gamemode === GameMode.spectator) continue;

        // 2. Check Armor
        const equip = player.getComponent(EntityComponentTypes.Equippable);
        const chest = equip.getEquipment(EquipmentSlot.Chest);
        
        const isWearingArmor = chest && chest.typeId === FLIGHT_ARMOR_ID;
        const hasTag = player.hasTag(FLIGHT_TAG);

        // 3. Logic: Enable Flight
        if (isWearingArmor && !hasTag) {
            // Run the command to enable flight
            player.runCommand("ability @s mayfly true");
            player.addTag(FLIGHT_TAG);
            player.sendMessage("§aFlight Enabled!");
            player.playSound("armor.equip_elytra");
        }
        
        // 4. Logic: Disable Flight
        else if (!isWearingArmor && hasTag) {
            // Run the command to disable flight
            player.runCommand("ability @s mayfly false");
            player.removeTag(FLIGHT_TAG);
            player.sendMessage("§cFlight Disabled.");
        }
    }
}, 10); // Run every 10 ticks (0.5 seconds) to save performance

import { world, system } from '@minecraft/server';

// CONFIGURATION
const ARROW_SPEED = 0.8; // How fast the arrow flies
const TURN_SPEED = 0.2;  // How sharp it can turn (0.1 = wide arc, 1.0 = instant snap)
const SEARCH_RADIUS = 10; // How far it looks for targets

// THE GAME LOOP
// This runs every single tick (0 delay)
system.runInterval(() => {
    
    // 1. Get the Dimension (Overworld)
    const overworld = world.getDimension("overworld");

    // 2. Find all Arrows currently flying
    // We use 'getEntities' to find specific types of entities
    const arrows = overworld.getEntities({ type: 'minecraft:arrow' });

    // 3. Loop through every arrow found
    for (const arrow of arrows) {
        
        // Safety Check: If the arrow hit the ground or is invalid, skip it
        // 'isValid' checks if the entity still exists in the world
        if (!arrow.isValid) continue; 

        // 4. Find the nearest target
        // We look for mobs excluding players and other arrows
        const targets = overworld.getEntities({
            location: arrow.location,
            maxDistance: SEARCH_RADIUS,
            excludeTypes: ['minecraft:player', 'minecraft:arrow', 'minecraft:item'],
            closest: 1 // We only want the single closest one
        });

        // If no target is found, let the arrow fly normally
        if (targets.length === 0) continue;

        const target = targets[0];

        // 5. Calculate the Vector (The Math Part)
        const arrowLoc = arrow.location;
        const targetLoc = target.location;

        // Direction = Target - Arrow
        // We aim for the target's body (y + 1.0) so we don't hit their feet
        const dx = targetLoc.x - arrowLoc.x;
        const dy = (targetLoc.y + 1.0) - arrowLoc.y;
        const dz = targetLoc.z - arrowLoc.z;

        // 6. Normalize the Vector
        // This ensures the arrow flies at a consistent speed, regardless of distance
        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
        
        // Prevent division by zero errors
        if (distance === 0) continue;

        const newVelocity = {
            x: (dx / distance) * ARROW_SPEED,
            y: (dy / distance) * ARROW_SPEED,
            z: (dz / distance) * ARROW_SPEED
        };

        // 7. Apply the new velocity
        // We use 'clearVelocity' first to stop gravity from dragging it down too much
        arrow.clearVelocity();
        arrow.applyImpulse(newVelocity);
        
        // Optional: Add particles so we can see it working
        overworld.spawnParticle("minecraft:basic_flame_particle", arrowLoc);
    }
});

import { world, system, MolangVariableMap } from '@minecraft/server';

const TARGET_RUN_SPEED = 0.35;
const WALL_DISTANCE = 1.0;
const MIN_HEIGHT = 1.2;
const STICK_FORCE = 0.08;
const JUMP_GRACE_TICKS = 20; 
const JUMP_HORIZONTAL_STRENGTH = 0.45; // Controlled horizontal speed
const JUMP_UPWARD_STRENGTH = 0.42;     // Standard MC jump height

const gracePeriods = new Map();
const wasJumping = new Map();

system.runInterval(() => {
    for (const player of world.getPlayers()) {
        const currentTick = system.currentTick;
        const isJumping = player.isJumping;
        const prevJumping = wasJumping.get(player.id) || false;
        const jumpPressed = isJumping && !prevJumping;
        wasJumping.set(player.id, isJumping);

        const dim = player.dimension;
        const loc = player.location;
        if (!loc || isNaN(loc.x)) continue;

        const viewDir = player.getViewDirection();
        const hLen = Math.sqrt(viewDir.x ** 2 + viewDir.z ** 2);
        if (hLen < 0.001) continue;

        const forward = { x: viewDir.x / hLen, z: viewDir.z / hLen };
        const rightDir = { x: -forward.z, z: forward.x };
        const leftDir = { x: forward.z, z: -forward.x };

        let wallSide = null;
        let sensorDir = null;

        const checkR = dim.getBlock({ x: loc.x + (rightDir.x * WALL_DISTANCE), y: loc.y + 1, z: loc.z + (rightDir.z * WALL_DISTANCE) });
        const checkL = dim.getBlock({ x: loc.x + (leftDir.x * WALL_DISTANCE), y: loc.y + 1, z: loc.z + (leftDir.z * WALL_DISTANCE) });

        if (checkR && !checkR.isAir && !checkR.isLiquid) {
            wallSide = 'right';
            sensorDir = rightDir;
        } else if (checkL && !checkL.isAir && !checkL.isLiquid) {
            wallSide = 'left';
            sensorDir = leftDir;
        }

        if (wallSide && sensorDir && player.isSprinting && !player.isOnGround) {
            gracePeriods.set(player.id, {
                expiry: currentTick + JUMP_GRACE_TICKS,
                lastWallDir: sensorDir
            });

            if (jumpPressed) {
                performPrecisionJump(player, sensorDir, forward);
                gracePeriods.delete(player.id);
                continue;
            }

            const currentVel = player.getVelocity();
            const targetVel = {
                x: forward.x * TARGET_RUN_SPEED,
                y: (viewDir.y * 0.2) + 0.08,
                z: forward.z * TARGET_RUN_SPEED
            };

            player.applyImpulse({
                x: targetVel.x - currentVel.x + (sensorDir.x * STICK_FORCE),
                y: targetVel.y - currentVel.y,
                z: targetVel.z - currentVel.z + (sensorDir.z * STICK_FORCE)
            });

            if (currentTick % 2 === 0) spawnWallParticles(dim, loc, sensorDir);
            player.addEffect("slow_falling", 2, { amplifier: 0, showParticles: false });

        } else if (gracePeriods.has(player.id)) {
            const data = gracePeriods.get(player.id);
            if (currentTick > data.expiry || player.isOnGround) {
                gracePeriods.delete(player.id);
            } else if (jumpPressed) {
                performPrecisionJump(player, data.lastWallDir, forward);
                gracePeriods.delete(player.id);
            }
        }
    }
});

function performPrecisionJump(player, wallDir, forward) {
    const currentVel = player.getVelocity();
    
    // ALGORITHM: Blend "Away from wall" with "Player Look Direction"
    // This makes the jump feel responsive to where the player is aiming.
    const jumpX = (forward.x * 0.3) + (wallDir.x * -0.4);
    const jumpZ = (forward.z * 0.3) + (wallDir.z * -0.4);
    
    // Normalize the horizontal jump vector
    const jLen = Math.sqrt(jumpX * jumpX + jumpZ * jumpZ);
    
    const targetJumpVel = {
        x: (jumpX / jLen) * JUMP_HORIZONTAL_STRENGTH,
        y: JUMP_UPWARD_STRENGTH,
        z: (jumpZ / jLen) * JUMP_HORIZONTAL_STRENGTH
    };

    // Apply the DELTA impulse (Target - Current)
    // This prevents the "Crazy Big" leap by canceling out existing speed.
    player.applyImpulse({
        x: targetJumpVel.x - currentVel.x,
        y: targetJumpVel.y - currentVel.y,
        z: targetJumpVel.z - currentVel.z
    });

    player.playSound("random.bowhit", { pitch: 0.8, volume: 0.4 });
    try {
        player.dimension.spawnParticle("minecraft:balloon_gas_particle", player.location);
    } catch (e) {}
}

function spawnWallParticles(dim, loc, sensorDir) {
    try {
        const vars = new MolangVariableMap();
        vars.setVector3("direction", { x: sensorDir.x, y: 0.1, z: sensorDir.z });
        dim.spawnParticle("minecraft:balloon_gas_particle", {
            x: loc.x + (sensorDir.x * 0.5),
            y: loc.y,
            z: loc.z + (sensorDir.z * 0.5)
        }, vars);
    } catch (e) {}
}

import { world, system, EntityComponentTypes, EquipmentSlot } from '@minecraft/server';

system.runInterval(() => {
    for (const player of world.getPlayers()) {
        const equip = player.getComponent(EntityComponentTypes.Equippable);
        const head = equip.getEquipment(EquipmentSlot.Head);
        const chest = equip.getEquipment(EquipmentSlot.Chest);
        const legs = equip.getEquipment(EquipmentSlot.Legs);
        const feet = equip.getEquipment(EquipmentSlot.Feet);

        const hasSet = head?.typeId === 'minecraft:netherite_helmet' &&
                       chest?.typeId === 'minecraft:netherite_chestplate' &&
                       legs?.typeId === 'minecraft:netherite_leggings' &&
                       feet?.typeId === 'minecraft:netherite_boots';

        if (hasSet) {
            player.addTag("netherite_set");
        } else {
            player.removeTag("netherite_set");
        }
    }
});

import { world } from '@minecraft/server';

world.afterEvents.itemUse.subscribe((event) => {
    const { source, itemStack } = event;

    if (itemStack.typeId === 'minecraft:nether_star') {
        console.warn(`[Debug] Teleport request by: ${source.name}`);

        // 1. Try to get Personal Spawn (Bed/Anchor)
        const personalSpawn = source.getSpawnPoint();

        if (personalSpawn) {
            console.warn(`[Debug] Found Personal Spawn at: ${personalSpawn.x}, ${personalSpawn.y}, ${personalSpawn.z}`);
            
            // Teleport to specific coordinates AND specific dimension
            source.teleport(
                { x: personalSpawn.x, y: personalSpawn.y, z: personalSpawn.z },
                { dimension: personalSpawn.dimension }
            );
        } 
        else {
            console.warn("[Debug] No Personal Spawn found. Using World Spawn.");
            
            // 2. Fallback to World Spawn (Default)
            const worldSpawn = world.getDefaultSpawnLocation();
            
            if (worldSpawn) {
                // World spawn is always in the Overworld
                const overworld = world.getDimension("overworld");
                source.teleport(worldSpawn, { dimension: overworld });
            } else {
                console.warn("[Debug] CRITICAL: No World Spawn found?");
            }
        }
    }
});

import { world, system } from '@minecraft/server';
import { ModalFormData } from '@minecraft/server-ui';

world.afterEvents.itemUse.subscribe((event) => {
    const { source: player, itemStack } = event;

    if (itemStack.typeId === 'minecraft:nether_star') {
        system.run(() => {
            showCircleMenu(player);
        });
    }
});

function showCircleMenu(player) {
    const form = new ModalFormData()
        .title("Circle Generator")
        .textField("Block ID", "minecraft:white_concrete", { defaultValue: "minecraft:white_concrete" })
        // FIXED: Using the new Options Object format
        .slider("Radius", 1, 50, { valueStep: 1, defaultValue: 12 })
        .slider("Height", 1, 50, { valueStep: 1, defaultValue: 10 });

    form.show(player).then((response) => {
        if (response.canceled) return;

        const [blockInput, radius, height] = response.formValues;
        
        let blockType = blockInput.trim();
        if (!blockType.includes(":")) {
            blockType = "minecraft:" + blockType;
        }

        player.sendMessage(`§eGenerating ${radius}x${height} circle of ${blockType}...`);
        
        generateCircle(player.dimension, player.location, blockType, radius, height, player);
    });
}

function generateCircle(dim, center, blockType, radius, height, player) {
    const cx = Math.floor(center.x);
    const cy = Math.floor(center.y);
    const cz = Math.floor(center.z);

    let blocksPlaced = 0;

    try {
        for (let y = 0; y < height; y++) {
            for (let x = -radius; x <= radius; x++) {
                for (let z = -radius; z <= radius; z++) {
                    const dist = Math.sqrt(x * x + z * z);

                    if (dist >= radius - 0.5 && dist <= radius + 0.5) {
                        try {
                            dim.getBlock({ 
                                x: cx + x, 
                                y: cy + y, 
                                z: cz + z 
                            })?.setType(blockType);
                            blocksPlaced++;
                        } catch (e) {
                        }
                    }
                }
            }
        }
        player.sendMessage(`§aDone! Placed ${blocksPlaced} blocks.`);
    } catch (e) {
        player.sendMessage(`§cError: Invalid Block ID '${blockType}' or area unloaded.`);
    }
}

import { world, system } from '@minecraft/server';

// --- CONFIGURATION ---
const TRIGGER_ITEM = 'minecraft:blaze_rod';
const COMMAND_TO_SPAM = 'summon lightning_bolt ^ ^ ^10'; // Example: Smite 10 blocks away
const DURATION_TICKS = 60;  // How long it spams (3 seconds)
const COOLDOWN_TICKS = 100; // How long you wait after (5 seconds)

// Trackers
const activeSpammers = new Map(); // <PlayerID, IntervalID>
const cooldowns = new Map();      // <PlayerID, GameTick>

world.afterEvents.itemUse.subscribe((event) => {
    const { source: player, itemStack } = event;

    if (itemStack.typeId !== TRIGGER_ITEM) return;

    const currentTick = system.currentTick;

    // 1. CHECK COOLDOWN
    if (cooldowns.has(player.id)) {
        const expiry = cooldowns.get(player.id);
        if (currentTick < expiry) {
            const remaining = Math.ceil((expiry - currentTick) / 20);
            player.onScreenDisplay.setActionBar(`§cOverheated! Wait ${remaining}s`);
            player.playSound("random.fizz");
            return;
        }
    }

    // 2. CHECK IF ALREADY SPAMMING (Prevent double activation)
    if (activeSpammers.has(player.id)) return;

    player.sendMessage("§aActivated!");
    
    // 3. START SPAMMING LOOP
    const intervalId = system.runInterval(() => {
        if (!player.isValid) {
            // Stop if player leaves
            stopSpam(player.id); 
            return;
        }

        try {
            player.runCommand(COMMAND_TO_SPAM);
        } catch (e) {
            // Ignore command errors
        }
    }, 1); // Run every 1 tick

    activeSpammers.set(player.id, intervalId);

    // 4. SCHEDULE STOP & COOLDOWN
    system.runTimeout(() => {
        stopSpam(player.id);
        
        // Set Cooldown
        cooldowns.set(player.id, system.currentTick + COOLDOWN_TICKS);
        player.onScreenDisplay.setActionBar("§cCooldown Started...");
        player.playSound("random.extinguish");
        
    }, DURATION_TICKS);
});

function stopSpam(playerId) {
    if (activeSpammers.has(playerId)) {
        system.clearRun(activeSpammers.get(playerId));
        activeSpammers.delete(playerId);
    }
}

import { world, system, StructureRotation } from '@minecraft/server';
import { ModalFormData, ActionFormData } from '@minecraft/server-ui';

// --- CONFIGURATION ---
const TOOL_ITEM = 'minecraft:stick';

// --- DATA STORAGE ---
function getAnchor() {
    const val = world.getDynamicProperty("toi_anchor");
    if (!val) return null;
    return JSON.parse(val);
}

function setAnchor(x, y, z) {
    world.setDynamicProperty("toi_anchor", JSON.stringify({ x, y, z }));
}

function getOffset(structName) {
    const val = world.getDynamicProperty(`toi_offset_${structName}`);
    if (!val) return { x: 0, z: 0, rot: 0 }; 
    return JSON.parse(val);
}

function saveOffset(structName, x, z, rot) {
    world.setDynamicProperty(`toi_offset_${structName}`, JSON.stringify({ x, z, rot }));
}

// --- MAIN EVENT ---
world.afterEvents.itemUse.subscribe((event) => {
    const { source: player, itemStack } = event;
    if (itemStack.typeId === TOOL_ITEM) {
        system.run(() => showMainMenu(player));
    }
});

// --- MENUS ---
async function showMainMenu(player) {
    const anchor = getAnchor();
    const anchorText = anchor ? `§a${anchor.x}, ${anchor.z}` : "§cNOT SET";

    const form = new ActionFormData()
        .title("Tower of Integrity V3")
        .body(`Anchor Point: ${anchorText}\n\nUse 'Calibrate' to fix off-center structures.`)
        .button("📍 Set Anchor Here")
        .button("📐 Calibrate a Level")
        .button("🏗️ Place Calibrated Level");

    const res = await form.show(player);
    if (res.canceled) return;

    if (res.selection === 0) {
        const l = player.location;
        setAnchor(Math.floor(l.x), Math.floor(l.y), Math.floor(l.z));
        player.sendMessage(`§aAnchor saved at ${Math.floor(l.x)}, ${Math.floor(l.z)}`);
    }
    if (res.selection === 1) showCalibrationMenu(player);
    if (res.selection === 2) showPlaceMenu(player);
}

async function showCalibrationMenu(player) {
    const anchor = getAnchor();
    if (!anchor) return player.sendMessage("§cSet Anchor first!");

    const form = new ModalFormData()
        .title("Calibrate Level")
        .textField("Structure Name", "mystructure:level_1", { defaultValue: "mystructure:level_1" })
        // FIXED: Using Options Object for sliders
        .slider("Nudge X (Left/Right)", -20, 20, { valueStep: 1, defaultValue: 0 })
        .slider("Nudge Z (Fwd/Back)", -20, 20, { valueStep: 1, defaultValue: 0 })
        .slider("Rotation", 0, 3, { valueStep: 1, defaultValue: 0 }) // 0, 90, 180, 270
        .toggle("§cSave & Overwrite?", { defaultValue: false });

    const res = await form.show(player);
    if (res.canceled) return;

    const [name, offX, offZ, rotIndex, doSave] = res.formValues;

    const mgr = world.structureManager;
    const struct = mgr.get(name);
    if (!struct) return player.sendMessage("§cStructure not found.");

    const size = struct.size;
    
    // 1. Calculate Base Position (Anchor - Half Size)
    let baseX = anchor.x - Math.floor(size.x / 2);
    let baseZ = anchor.z - Math.floor(size.z / 2);

    const rotations = [StructureRotation.None, StructureRotation.Rotate90, StructureRotation.Rotate180, StructureRotation.Rotate270];
    const rotation = rotations[rotIndex];

    // If rotated 90/270, dimensions flip
    if (rotation === StructureRotation.Rotate90 || rotation === StructureRotation.Rotate270) {
        baseX = anchor.x - Math.floor(size.z / 2);
        baseZ = anchor.z - Math.floor(size.x / 2);
    }

    // 2. Apply Manual Nudge
    const finalX = baseX + offX;
    const finalZ = baseZ + offZ;
    const finalY = Math.floor(player.location.y);

    try {
        mgr.place(name, player.dimension, { x: finalX, y: finalY, z: finalZ }, { rotation: rotation });
        player.sendMessage(`§ePreview placed. Nudge: ${offX}, ${offZ}`);
        
        // Visual Marker
        player.dimension.spawnParticle("minecraft:villager_happy", {x: anchor.x+0.5, y: finalY+2, z: anchor.z+0.5});

        if (doSave) {
            saveOffset(name, offX, offZ, rotIndex);
            player.sendMessage(`§aCalibration SAVED for '${name}'!`);
        } else {
            player.sendMessage("§7(Settings not saved. Toggle 'Save' to keep.)");
        }

    } catch (e) {
        player.sendMessage(`§cError: ${e}`);
    }
}

async function showPlaceMenu(player) {
    const anchor = getAnchor();
    if (!anchor) return player.sendMessage("§cSet Anchor first!");

    const form = new ModalFormData()
        .title("Place Calibrated Level")
        .textField("Structure Name", "mystructure:level_1", { defaultValue: "mystructure:level_1" })
        // FIXED: Using Options Object for sliders
        .slider("Height Y", -64, 320, { valueStep: 1, defaultValue: Math.floor(player.location.y) });

    const res = await form.show(player);
    if (res.canceled) return;

    const [name, y] = res.formValues;

    // 1. Load Saved Calibration
    const saved = getOffset(name); // Returns {x, z, rot}
    
    const mgr = world.structureManager;
    const struct = mgr.get(name);
    if (!struct) return player.sendMessage("§cStructure not found.");
    const size = struct.size;

    // 2. Re-Calculate Logic
    let baseX = anchor.x - Math.floor(size.x / 2);
    let baseZ = anchor.z - Math.floor(size.z / 2);

    const rotations = [StructureRotation.None, StructureRotation.Rotate90, StructureRotation.Rotate180, StructureRotation.Rotate270];
    const rotation = rotations[saved.rot];

    if (rotation === StructureRotation.Rotate90 || rotation === StructureRotation.Rotate270) {
        baseX = anchor.x - Math.floor(size.z / 2);
        baseZ = anchor.z - Math.floor(size.x / 2);
    }

    // 3. Apply Saved Nudge
    const finalX = baseX + saved.x;
    const finalZ = baseZ + saved.z;

    try {
        mgr.place(name, player.dimension, { x: finalX, y: y, z: finalZ }, { rotation: rotation });
        player.sendMessage(`§aPlaced '${name}' using saved calibration.`);
    } catch (e) {
        player.sendMessage(`§cError: ${e}`);
    }
}

import { world, system, EntityComponentTypes, EquipmentSlot, EffectTypes } from '@minecraft/server';

const DODGE_BOOTS = 'minecraft:diamond_boots';
const DETECT_RANGE = 3.5; // Increased range slightly to react faster
const DODGE_POWER = 0.8;  // Weaker dash
const COOLDOWN_TICKS = 15;

const PROJECTILE_TYPES = [
    "minecraft:arrow",
    "minecraft:thrown_trident",
    "minecraft:snowball",
    "minecraft:small_fireball",
    "minecraft:fireball",
    "minecraft:wither_skull",
    "minecraft:wither_skull_dangerous"
];

const cooldowns = new Map();

system.runInterval(() => {
    const currentTick = system.currentTick;

    for (const player of world.getPlayers()) {
        const equip = player.getComponent(EntityComponentTypes.Equippable);
        const boots = equip.getEquipment(EquipmentSlot.Feet);

        if (!boots || boots.typeId !== DODGE_BOOTS) continue;

        if (cooldowns.has(player.id) && cooldowns.get(player.id) > currentTick) continue;

        const dimension = player.dimension;
        const nearbyEntities = dimension.getEntities({
            location: player.location,
            maxDistance: DETECT_RANGE,
            excludeTypes: ["minecraft:player", "minecraft:item", "minecraft:xp_orb"]
        });

        for (const entity of nearbyEntities) {
            if (!PROJECTILE_TYPES.includes(entity.typeId)) continue;

            const projComp = entity.getComponent("minecraft:projectile");
            if (projComp) {
                try {
                    const owner = projComp.owner;
                    if (owner && owner.id === player.id) continue;
                } catch (e) {}
            }

            const pVel = entity.getVelocity();
            const speed = Math.sqrt(pVel.x**2 + pVel.y**2 + pVel.z**2);
            
            if (speed < 0.2) continue;

            let dodgeX = -pVel.z;
            let dodgeZ = pVel.x;
            
            const len = Math.sqrt(dodgeX**2 + dodgeZ**2);
            if (len === 0) continue;

            const side = Math.random() > 0.5 ? 1 : -1;

            player.applyImpulse({
                x: (dodgeX / len) * DODGE_POWER * side,
                y: 0.3, 
                z: (dodgeZ / len) * DODGE_POWER * side
            });

            // I-FRAMES: Give Resistance 255 for 0.5 seconds
            // This guarantees you take 0 damage even if the arrow clips you
            player.addEffect(EffectTypes.get("resistance"), 10, { amplifier: 255, showParticles: false });

            player.playSound("mob.enderdragon.flap");
            try {
                dimension.spawnParticle("minecraft:large_explosion", player.location);
            } catch (e) {}

            cooldowns.set(player.id, currentTick + COOLDOWN_TICKS);
            break; 
        }
    }
});

import { world, ItemStack } from '@minecraft/server';

world.afterEvents.playerSpawn.subscribe((event) => {
    const player = event.player;
    if (!player.hasTag('joined')) {
        player.addTag('joined');
        const inventory = player.getComponent('inventory').container;
        inventory.addItem(new ItemStack('minecraft:diamond'));
    }
});

import { world, system, ItemStack, EnchantmentTypes, GameMode } from '@minecraft/server';

const LORE_TAG = "§bAuto-Smelt";
const APPLY_ITEM = 'minecraft:nether_star';

const SMELT_MAP = {
    'minecraft:iron_ore': 'minecraft:iron_ingot',
    'minecraft:deepslate_iron_ore': 'minecraft:iron_ingot',
    'minecraft:gold_ore': 'minecraft:gold_ingot',
    'minecraft:deepslate_gold_ore': 'minecraft:gold_ingot',
    'minecraft:copper_ore': 'minecraft:copper_ingot',
    'minecraft:deepslate_copper_ore': 'minecraft:copper_ingot',
    'minecraft:ancient_debris': 'minecraft:netherite_scrap',
    'minecraft:raw_iron_block': 'minecraft:iron_block',
    'minecraft:raw_copper_block': 'minecraft:copper_block',
    'minecraft:raw_gold_block': 'minecraft:gold_block'
};

const NO_FORTUNE = [
    'minecraft:ancient_debris',
    'minecraft:raw_iron_block',
    'minecraft:raw_copper_block',
    'minecraft:raw_gold_block'
];

world.afterEvents.itemUse.subscribe((event) => {
    const { source: player, itemStack } = event;

    if (itemStack.typeId === APPLY_ITEM) {
        const inv = player.getComponent('inventory').container;
        const targetItem = inv.getItem(0);

        if (targetItem && (targetItem.typeId.includes('_pickaxe') || targetItem.typeId.includes('_axe') || targetItem.typeId.includes('_shovel'))) {
            const lore = targetItem.getLore();
            if (!lore.includes(LORE_TAG)) {
                lore.push(LORE_TAG);
                targetItem.setLore(lore);
                inv.setItem(0, targetItem);
                
                player.playSound("random.levelup");
                player.sendMessage(`§aApplied ${LORE_TAG} §ato the item in Slot 1!`);
                
                if (player.getGameMode() !== GameMode.creative) {
                    if (itemStack.amount > 1) {
                        itemStack.amount--;
                        inv.setItem(player.selectedSlotIndex, undefined); 
                        player.getComponent('inventory').container.addItem(itemStack); 
                        inv.setItem(player.selectedSlotIndex, itemStack); 
                    } else {
                         player.getComponent('inventory').container.setItem(player.selectedSlotIndex, undefined);
                    }
                }
            } else {
                player.sendMessage("§cItem in Slot 1 already has Auto-Smelt.");
            }
        } else {
            player.sendMessage("§cPlease put a Tool in the first hotbar slot.");
        }
    }
});

world.beforeEvents.playerBreakBlock.subscribe((event) => {
    const { player, block, itemStack } = event;

    if (!itemStack) return;
    
    const lore = itemStack.getLore();
    if (!lore.includes(LORE_TAG)) return;

    const resultId = SMELT_MAP[block.typeId];
    if (!resultId) return;

    event.cancel = true;

    system.run(() => {
        const dim = player.dimension;
        const loc = block.location;

        dim.setBlockType(loc, 'minecraft:air');

        let dropAmount = 1;
        
        if (!NO_FORTUNE.includes(block.typeId)) {
            const fortune = itemStack.getComponent('enchantments')?.enchantments?.getEnchantment(EnchantmentTypes.get('fortune'))?.level || 0;
            
            if (fortune > 0) {
                const r = Math.random();
                if (fortune === 1 && r > 0.66) dropAmount = 2;
                else if (fortune === 2) {
                    if (r > 0.75) dropAmount = 3;
                    else if (r > 0.5) dropAmount = 2;
                }
                else if (fortune === 3) {
                    if (r > 0.8) dropAmount = 4;
                    else if (r > 0.6) dropAmount = 3;
                    else if (r > 0.4) dropAmount = 2;
                }
            }
            
            if (block.typeId.includes('copper')) {
                dropAmount = Math.floor(dropAmount * (Math.random() * 3 + 2));
            }
        }

        dim.spawnItem(new ItemStack(resultId, dropAmount), { x: loc.x + 0.5, y: loc.y + 0.5, z: loc.z + 0.5 });
        dim.spawnEntity('minecraft:xp_orb', { x: loc.x + 0.5, y: loc.y + 0.5, z: loc.z + 0.5 });

        if (player.getGameMode() !== GameMode.creative) {
            const unbreaking = itemStack.getComponent('enchantments')?.enchantments?.getEnchantment(EnchantmentTypes.get('unbreaking'))?.level || 0;
            const chance = 100 / (unbreaking + 1);
            
            if (Math.random() * 100 < chance) {
                const durability = itemStack.getComponent('durability');
                if (durability) {
                    if (durability.damage + 1 >= durability.maxDurability) {
                        player.getComponent('inventory').container.setItem(player.selectedSlotIndex, undefined);
                        player.playSound("random.break");
                    } else {
                        durability.damage += 1;
                        player.getComponent('inventory').container.setItem(player.selectedSlotIndex, itemStack);
                    }
                }
            }
        }
    });
});

import { world, system, EffectTypes, EntityComponentTypes, EquipmentSlot } from '@minecraft/server';

// --- CONFIGURATION ---
const MAX_SANITY = 100;
const DRAIN_RATE = 4;      // How much sanity you lose per second in the dark
const REGEN_RATE = 5;      // How much you gain in light
const LIGHT_THRESHOLD = 1; // Light level must be higher than this to be "Safe"

// Safe Items (Holding these stops the drain)
const LIGHT_ITEMS = [
    'minecraft:torch',
    'minecraft:soul_torch',
    'minecraft:lantern',
    'minecraft:soul_lantern',
    'minecraft:glowstone',
    'minecraft:sea_lantern',
    'minecraft:shroomlight',
    'minecraft:ochre_froglight',
    'minecraft:pearlescent_froglight',
    'minecraft:verdant_froglight',
    'minecraft:end_rod'
];

// Trackers
const playerSanity = new Map(); // <PlayerID, SanityValue>

system.runInterval(() => {
    for (const player of world.getPlayers()) {
        // 1. GET CURRENT SANITY
        let sanity = playerSanity.get(player.id) ?? MAX_SANITY;

        // 2. CHECK ENVIRONMENT
        const dim = player.dimension;
        const loc = player.location;
        
        // Check Light Level at head height
        // Note: In some versions, getLightLevel() might be experimental. 
        // If it fails, we assume it's dark to be safe/scary.
        let lightLevel = 0;
        try {
            const block = dim.getBlock({ x: loc.x, y: loc.y + 1, z: loc.z });
            if (block) {
                // Try to get light level (Sky + Block light)
                // If API doesn't support it yet, we default to 0 (Hardcore mode)
                lightLevel = block.getLightLevel ? block.getLightLevel() : 0;
            }
        } catch (e) {
            lightLevel = 0;
        }

        // 3. CHECK HELD ITEM (The "Amnesia" Mechanic)
        const equip = player.getComponent(EntityComponentTypes.Equippable);
        const mainHand = equip.getEquipment(EquipmentSlot.Mainhand);
        const offHand = equip.getEquipment(EquipmentSlot.Offhand);

        const isHoldingLight = (mainHand && LIGHT_ITEMS.includes(mainHand.typeId)) || 
                               (offHand && LIGHT_ITEMS.includes(offHand.typeId));

        // 4. CALCULATE DRAIN / REGEN
        if (isHoldingLight || lightLevel > LIGHT_THRESHOLD) {
            sanity += REGEN_RATE;
        } else {
            sanity -= DRAIN_RATE;
        }

        // Clamp values (0 to 100)
        if (sanity > MAX_SANITY) sanity = MAX_SANITY;
        if (sanity < 0) sanity = 0;

        playerSanity.set(player.id, sanity);

        // 5. DISPLAY SANITY BAR
        const bars = "||||||||||";
        const filled = Math.ceil(sanity / 10);
        const color = sanity > 50 ? "§a" : (sanity > 20 ? "§e" : "§c");
        const barStr = color + bars.substring(0, filled) + "§8" + bars.substring(filled);
        
        player.onScreenDisplay.setActionBar(`Sanity: [${barStr}§r]`);

        // 6. HORROR EFFECTS (The Scary Part)
        if (sanity < 80) {
            // Heartbeat Sound
            if (system.currentTick % 20 === 0) {
                player.playSound("mob.warden.heartbeat", { volume: 1.0, pitch: 1.0 });
            }
        }

        if (sanity < 50) {
            // Random Creepy Sounds
            if (Math.random() < 0.05) {
                const sounds = ["ambient.cave", "mob.creeper.say", "mob.endermen.stare", "step.wood"];
                const randSound = sounds[Math.floor(Math.random() * sounds.length)];
                player.playSound(randSound, { volume: 0.5, pitch: 0.5 });
            }
            // Hallucination Particles
            if (Math.random() < 0.1) {
                dim.spawnParticle("minecraft:sculk_soul_particle", player.getHeadLocation());
            }
        }

        if (sanity < 30) {
            // Vision Pulse
            if (system.currentTick % 40 === 0) {
                player.addEffect(EffectTypes.get("blindness"), 40, { amplifier: 0, showParticles: false });
            }
            // Shake Camera (using damage sound without damage)
            if (Math.random() < 0.02) {
                player.playSound("game.player.hurt");
            }
        }

        if (sanity <= 0) {
            // HEART ATTACK
            if (system.currentTick % 20 === 0) {
                player.applyDamage(2, { cause: "magic" });
                player.playSound("game.player.die");
                player.sendMessage("§c§lYOUR MIND SNAPS...");
            }
        }
    }
}, 20); // Run every second

import { world, system } from '@minecraft/server';

system.runInterval(() => {
    for (const player of world.getPlayers()) {
        const dimension = player.dimension;
        const eggs = dimension.getEntities({ type: 'minecraft:egg' });

        for (const egg of eggs) {
            const loc = egg.location;
            const blockBelow = dimension.getBlock({ 
                x: Math.floor(loc.x), 
                y: Math.floor(loc.y - 1), 
                z: Math.floor(loc.z) 
            });

            if (blockBelow && blockBelow.isAir) {
                blockBelow.setType('minecraft:white_wool');
            }
        }
    }
});

import { world, system, EntityComponentTypes, EquipmentSlot } from '@minecraft/server';

const TARGET_JUMP_VELOCITY = 0.8;
const JUMP_TAG = "can_double_jump";
const MIN_AIR_TIME = 5;
const REQUIRED_BOOTS = 'minecraft:diamond_boots';

const wasJumping = new Map();
const lastGroundTick = new Map();

system.runInterval(() => {
    const currentTick = system.currentTick;

    for (const player of world.getPlayers()) {
        if (player.isOnGround || player.isClimbing || player.isSwimming) {
            if (!player.hasTag(JUMP_TAG)) {
                player.addTag(JUMP_TAG);
            }
            lastGroundTick.set(player.id, currentTick);
            wasJumping.set(player.id, player.isJumping);
            continue;
        }

        const lastOnGround = lastGroundTick.get(player.id) || 0;
        if (currentTick - lastOnGround < MIN_AIR_TIME) {
            wasJumping.set(player.id, player.isJumping);
            continue;
        }

        const isJumping = player.isJumping;
        const prevJumping = wasJumping.get(player.id) || false;
        const jumpPressed = isJumping && !prevJumping;

        wasJumping.set(player.id, isJumping);

        if (jumpPressed && player.hasTag(JUMP_TAG)) {
            const equip = player.getComponent(EntityComponentTypes.Equippable);
            const boots = equip.getEquipment(EquipmentSlot.Feet);

            if (boots && boots.typeId === REQUIRED_BOOTS) {
                const currentVel = player.getVelocity();

                player.applyImpulse({
                    x: 0,
                    y: TARGET_JUMP_VELOCITY - currentVel.y,
                    z: 0
                });

                player.playSound("mob.ghast.fireball", { pitch: 1.2, volume: 0.6 });
                try {
                    player.dimension.spawnParticle("minecraft:cloud_particle", player.location);
                } catch (e) {}

                player.removeTag(JUMP_TAG);
            }
        }
    }
});

import { world, system } from "@minecraft/server";

const LEVELS = [
    // MINESHAFT (Confirmed Working)
    { name: "toh:mineshaft",  x: 196, y: -50, z: -1 },

    // MAIN GROUP (Base 223, 23)
    // I added the small offsets you mentioned earlier (2, 1) and (2, 0)
    { name: "toh:highsky",    x: 225, y: -50, z: 24 }, 
    { name: "toh:rockyroad",  x: 225, y: -50, z: 23 },
    { name: "toh:vineland",   x: 223, y: -50, z: 23 },

    // WAYTORCH (Base 223, 25)
    { name: "toh:waytorch",   x: 223, y: -50, z: 25 }
];

world.beforeEvents.chatSend.subscribe((event) => {
    const { sender, message } = event;

    if (message.trim() === ".test") {
        event.cancel = true;

        const randomLevel = LEVELS[Math.floor(Math.random() * LEVELS.length)];

        system.run(() => {
            try {
                const pos = { x: randomLevel.x, y: randomLevel.y, z: randomLevel.z };
                
                world.structureManager.place(randomLevel.name, sender.dimension, pos);
                
                sender.sendMessage(`§a[ToI] Placed §e${randomLevel.name}§a at ${pos.x}, ${pos.y}, ${pos.z}`);
            } catch (e) {
                sender.sendMessage(`§c[ToI] Error: '${randomLevel.name}' not found.`);
            }
        });
    }
});

import { world, system, ItemStack, EntityComponentTypes, EffectTypes } from '@minecraft/server';

const SWORD_NAME = "Elemental Sword";
const SWITCH_COOLDOWN = 10;

const ELEMENTS = {
    'minecraft:netherite_sword': { 
        next: 'minecraft:diamond_sword', 
        type: 'fire', 
        color: "§c[Fire]", 
        particle: "minecraft:basic_flame_particle",
        sound: "mob.blaze.shoot",
        particleCount: 20 
    },
    'minecraft:diamond_sword': { 
        next: 'minecraft:iron_sword', 
        type: 'ice', 
        color: "§b[Ice]", 
        particle: "minecraft:snowflake_particle",
        sound: "random.glass",
        particleCount: 20 
    },
    'minecraft:iron_sword': { 
        next: 'minecraft:netherite_sword', 
        type: 'wind', 
        color: "§f[Wind]", 
        particle: "minecraft:knockback_roar_particle",
        sound: "item.trident.throw",
        particleCount: 1 
    }
};

const cooldowns = new Map();
const wasSneaking = new Map();

system.runInterval(() => {
    const currentTick = system.currentTick;

    for (const player of world.getPlayers()) {
        const isSneaking = player.isSneaking;
        const prevSneaking = wasSneaking.get(player.id) || false;
        wasSneaking.set(player.id, isSneaking);

        if (isSneaking && !prevSneaking) {
            if (cooldowns.has(player.id) && cooldowns.get(player.id) > currentTick) continue;

            const inv = player.getComponent(EntityComponentTypes.Inventory).container;
            const item = inv.getItem(player.selectedSlotIndex);

            if (!item || item.nameTag !== SWORD_NAME || !ELEMENTS[item.typeId]) continue;

            const currentElement = ELEMENTS[item.typeId];
            const nextId = currentElement.next;
            const nextElement = ELEMENTS[nextId];

            const newItem = new ItemStack(nextId, 1);
            newItem.nameTag = SWORD_NAME;
            
            const lore = item.getLore();
            newItem.setLore(lore);
            
            const oldEnchants = item.getComponent("minecraft:enchantable");
            const newEnchants = newItem.getComponent("minecraft:enchantable");
            
            if (oldEnchants && newEnchants) {
                for (const ench of oldEnchants.getEnchantments()) {
                    newEnchants.addEnchantment(ench);
                }
            }

            inv.setItem(player.selectedSlotIndex, newItem);

            player.onScreenDisplay.setActionBar(`§7Switched to: ${nextElement.color}`);
            
            let pitch = 1.0;
            if (nextElement.type === 'ice') pitch = 1.5;

            player.playSound(nextElement.sound, { pitch: pitch, volume: 1.0 });
            
            const headLoc = player.getHeadLocation();
            for (let i = 0; i < nextElement.particleCount; i++) {
                const offsetX = (Math.random() - 0.5) * 1.5;
                const offsetY = (Math.random() - 0.5) * 1.5;
                const offsetZ = (Math.random() - 0.5) * 1.5;

                try {
                    player.dimension.spawnParticle(nextElement.particle, {
                        x: headLoc.x + offsetX,
                        y: headLoc.y + offsetY,
                        z: headLoc.z + offsetZ
                    });
                } catch (e) {}
            }

            cooldowns.set(player.id, currentTick + SWITCH_COOLDOWN);
        }
    }
});

world.afterEvents.entityHitEntity.subscribe((event) => {
    const { damagingEntity, hitEntity } = event;

    if (damagingEntity.typeId !== 'minecraft:player') return;

    const inv = damagingEntity.getComponent(EntityComponentTypes.Inventory).container;
    const item = inv.getItem(damagingEntity.selectedSlotIndex);

    if (!item || item.nameTag !== SWORD_NAME) return;

    const elementData = ELEMENTS[item.typeId];
    if (!elementData) return;

    const dim = damagingEntity.dimension;
    const loc = hitEntity.location;

    switch (elementData.type) {
        case 'fire':
            hitEntity.setOnFire(5, true);
            dim.spawnParticle("minecraft:lava_particle", loc);
            damagingEntity.playSound("mob.ghast.fireball");
            break;

        case 'ice':
            hitEntity.addEffect(EffectTypes.get("slowness"), 60, { amplifier: 2 });
            dim.spawnParticle("minecraft:snowflake_particle", loc);
            damagingEntity.playSound("random.glass", { pitch: 1.5, volume: 2.0 });
            break;

        case 'wind':
            hitEntity.applyImpulse({ x: 0, y: 1.2, z: 0 });
            dim.spawnParticle("minecraft:knockback_roar_particle", loc);
            damagingEntity.playSound("item.trident.riptide_2");
            break;
    }
});

import { world, system, EffectTypes } from '@minecraft/server';

const SHADOW_TAG = "shadow_walker";
const MAX_SAFE_LIGHT = 7;

const playerStates = new Map();

system.runInterval(() => {
    for (const player of world.getPlayers()) {
        if (!player.hasTag(SHADOW_TAG)) {
            playerStates.delete(player.id);
            continue;
        }

        const dim = player.dimension;
        const loc = player.location;
        const viewDir = player.getViewDirection();

        let lightLevel = 15;
        try {
            const headBlock = dim.getBlock({ x: loc.x, y: loc.y + 1, z: loc.z });
            if (headBlock) {
                lightLevel = headBlock.getLightLevel();
            }
        } catch (e) {
            lightLevel = 15;
        }

        const inShadow = lightLevel <= MAX_SAFE_LIGHT;
        
        let state = playerStates.get(player.id);
        if (!state) {
            state = { wasInShadow: false, burnTimer: 0 };
            playerStates.set(player.id, state);
        }

        if (inShadow) {
            if (!state.wasInShadow) {
                player.onScreenDisplay.setActionBar("§8§lShadow Form Activated");
                player.playSound("mob.endermen.portal");
            }

            player.addEffect(EffectTypes.get("invisibility"), 20, { amplifier: 0, showParticles: false });
            player.addEffect(EffectTypes.get("speed"), 20, { amplifier: 1, showParticles: false });

            if (system.currentTick % 4 === 0) {
                try {
                    const pLoc = {
                        x: loc.x - (viewDir.x * 0.5),
                        y: loc.y + 0.8,
                        z: loc.z - (viewDir.z * 0.5)
                    };
                    dim.spawnParticle("minecraft:soul_particle", pLoc);
                } catch (e) {}
            }

            state.wasInShadow = true;
            state.burnTimer = 0; 

        } else {
            player.setOnFire(2, true);

            state.burnTimer++;

            if (state.burnTimer >= 60) {
                player.onScreenDisplay.setActionBar(`§c§lBURNING! (Light: ${lightLevel})`);
                player.playSound("mob.ghast.scream", { volume: 1.0, pitch: 0.8 });
                state.burnTimer = 0; 
            }

            state.wasInShadow = false;
        }
    }
}, 1);

import { world, system, EntityComponentTypes } from '@minecraft/server';

const ROULETTE_TAG = "roulette";
const INTERVAL_TICKS = 150; 

system.runInterval(() => {
    for (const player of world.getPlayers()) {
        if (!player.hasTag(ROULETTE_TAG)) continue;

        const inv = player.getComponent(EntityComponentTypes.Inventory).container;
        const inventorySize = inv.size; 
        
        const allItems = [];
        for (let i = 0; i < inventorySize; i++) {
            allItems.push(inv.getItem(i));
        }

        for (let i = allItems.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allItems[i], allItems[j]] = [allItems[j], allItems[i]];
        }

        for (let i = 0; i < inventorySize; i++) {
            inv.setItem(i, allItems[i]);
        }

        player.playSound("mob.shulker.teleport", { pitch: 1.5, volume: 0.5 });
        player.onScreenDisplay.setActionBar("§d§k||§r §dInventory Scrambled! §d§k||");
    }
}, INTERVAL_TICKS);

import { system, GameMode, CommandPermissionLevel, CustomCommandStatus } from '@minecraft/server';

system.beforeEvents.startup.subscribe((event) => {
    const registry = event.customCommandRegistry;

    registry.registerCommand(
        {
            name: "sc:gmc",
            description: "Set Creative",
            permissionLevel: CommandPermissionLevel.Admin,
            parameters: []
        },
        (origin) => {
            const player = origin.sourceEntity;
            if (!player || player.typeId !== 'minecraft:player') return { status: CustomCommandStatus.Fail };

            system.run(() => {
                player.setGameMode(GameMode.creative);
            });

            return { status: CustomCommandStatus.Success };
        }
    );

    registry.registerCommand(
        {
            name: "sc:gms",
            description: "Set Survival",
            permissionLevel: CommandPermissionLevel.Admin,
            parameters: []
        },
        (origin) => {
            const player = origin.sourceEntity;
            if (!player || player.typeId !== 'minecraft:player') return { status: CustomCommandStatus.Fail };

            system.run(() => {
                player.setGameMode(GameMode.survival);
            });

            return { status: CustomCommandStatus.Success };
        }
    );
});

import { world, system, ItemStack, EntityComponentTypes, EffectTypes, EquipmentSlot } from '@minecraft/server';

const CRAFTING_BLOCK = 'minecraft:anvil';
const CRAFT_DISTANCE = 1.2;
const MAX_RUNE_LEVEL = 3;
const MAX_SOCKETS = 2;

const RUNES = {
    'minecraft:coal': { name: "Charred", type: 'on_hit', effect: 'wither', level: 1, color: "§8", particle: "minecraft:basic_smoke_particle", sound: "random.fizz" },
    'minecraft:coal_block': { name: "Charred", type: 'on_hit', effect: 'wither', level: 2, color: "§8", particle: "minecraft:large_smoke_particle", sound: "mob.ghast.fireball" },
    'minecraft:wither_skeleton_skull': { name: "Charred", type: 'on_hit', effect: 'wither', level: 3, color: "§8", particle: "minecraft:sculk_soul_particle", sound: "mob.wither.spawn" },

    'minecraft:raw_iron': { name: "Reinforced", type: 'passive', effect: 'resistance', level: 1, color: "§7", particle: "minecraft:silver_spore_particle", sound: "random.anvil_land" },
    'minecraft:iron_ingot': { name: "Reinforced", type: 'passive', effect: 'resistance', level: 2, color: "§7", particle: "minecraft:crit_particle", sound: "random.anvil_use" },
    'minecraft:iron_block': { name: "Reinforced", type: 'passive', effect: 'resistance', level: 3, color: "§7", particle: "minecraft:knockback_roar_particle", sound: "mob.zoglin.angry" },

    'minecraft:raw_gold': { name: "Swift", type: 'passive', effect: 'speed', level: 1, color: "§e", particle: "minecraft:electric_spark", sound: "random.orb" },
    'minecraft:gold_ingot': { name: "Swift", type: 'passive', effect: 'speed', level: 2, color: "§e", particle: "minecraft:totem_particle", sound: "random.levelup" },
    'minecraft:gold_block': { name: "Swift", type: 'passive', effect: 'speed', level: 3, color: "§e", particle: "minecraft:conduit_particle", sound: "random.totem" },

    'minecraft:diamond': { name: "Sharp", type: 'passive', effect: 'strength', level: 1, color: "§b", particle: "minecraft:diamond_particle", sound: "random.glass" },
    'minecraft:diamond_block': { name: "Sharp", type: 'passive', effect: 'strength', level: 2, color: "§b", particle: "minecraft:blue_flame_particle", sound: "block.amethyst_block.break" },
    'minecraft:netherite_ingot': { name: "Sharp", type: 'passive', effect: 'strength', level: 3, color: "§b", particle: "minecraft:obsidian_tear_particle", sound: "mob.wither.death" },

    'minecraft:emerald': { name: "Vitality", type: 'passive', effect: 'regeneration', level: 1, color: "§a", particle: "minecraft:villager_happy", sound: "random.pop" },
    'minecraft:emerald_block': { name: "Vitality", type: 'passive', effect: 'regeneration', level: 2, color: "§a", particle: "minecraft:heart_particle", sound: "random.drink" },
    'minecraft:totem_of_undying': { name: "Vitality", type: 'passive', effect: 'regeneration', level: 3, color: "§a", particle: "minecraft:totem_particle", sound: "random.totem" },

    'minecraft:redstone': { name: "Hasty", type: 'passive', effect: 'haste', level: 1, color: "§c", particle: "minecraft:redstone_torch_dust_particle", sound: "random.click" },
    'minecraft:redstone_block': { name: "Hasty", type: 'passive', effect: 'haste', level: 2, color: "§c", particle: "minecraft:redstone_ore_dust_particle", sound: "random.bow" },
    'minecraft:echo_shard': { name: "Hasty", type: 'passive', effect: 'haste', level: 3, color: "§c", particle: "minecraft:sculk_charge_particle", sound: "mob.warden.sonic_boom" },

    'minecraft:raw_copper': { name: "Storm", type: 'on_hit', effect: 'lightning', level: 1, color: "§6", particle: "minecraft:copper_wax_particle", sound: "random.fizz" },
    'minecraft:copper_ingot': { name: "Storm", type: 'on_hit', effect: 'lightning', level: 2, color: "§6", particle: "minecraft:electric_spark", sound: "item.trident.thunder" },
    'minecraft:lightning_rod': { name: "Storm", type: 'on_hit', effect: 'lightning', level: 3, color: "§6", particle: "minecraft:lightning_bolt_particle", sound: "ambient.weather.lightning.impact" }
};

function toRoman(num) {
    if (num === 1) return "I";
    if (num === 2) return "II";
    if (num === 3) return "III";
    return "I";
}

function getRuneLevel(loreLine) {
    if (loreLine.endsWith("III")) return 3;
    if (loreLine.endsWith("II")) return 2;
    if (loreLine.endsWith("I")) return 1;
    return 0;
}

system.runInterval(() => {
    const overworld = world.getDimension("overworld");
    const items = overworld.getEntities({ type: 'minecraft:item' });
    const processed = new Set();

    for (const itemA of items) {
        if (processed.has(itemA.id)) continue;
        const stackA = itemA.getComponent("item").itemStack;
        if (!stackA.typeId.includes("_sword")) continue;

        const blockBelow = overworld.getBlock({ x: Math.floor(itemA.location.x), y: Math.floor(itemA.location.y - 0.1), z: Math.floor(itemA.location.z) });
        if (!blockBelow || blockBelow.typeId !== CRAFTING_BLOCK) continue;

        for (const itemB of items) {
            if (itemA.id === itemB.id || processed.has(itemB.id)) continue;
            const stackB = itemB.getComponent("item").itemStack;
            const runeData = RUNES[stackB.typeId];
            if (!runeData) continue;

            const dx = itemA.location.x - itemB.location.x;
            const dy = itemA.location.y - itemB.location.y;
            const dz = itemA.location.z - itemB.location.z;
            if (Math.sqrt(dx * dx + dy * dy + dz * dz) < CRAFT_DISTANCE) {
                processed.add(itemA.id);
                processed.add(itemB.id);
                startCinematicCraft(itemA, itemB, runeData, overworld);
            }
        }
    }
}, 10);

function startCinematicCraft(swordEntity, materialEntity, runeData, dimension) {
    const player = dimension.getPlayers({ location: swordEntity.location, closest: 1 })[0];
    const swordStack = swordEntity.getComponent("item").itemStack;
    const materialTypeId = materialEntity.getComponent("item").itemStack.typeId;
    materialEntity.remove();

    let tick = 0;
    const startLoc = { ...swordEntity.location };
    const isMidas = swordStack.typeId === 'minecraft:golden_sword' && materialTypeId === 'minecraft:gold_ingot';

    const interval = system.runInterval(() => {
        if (!swordEntity.isValid) { system.clearRun(interval); return; }
        tick++;

        if (tick < 30) {
            swordEntity.teleport({ x: startLoc.x, y: startLoc.y + (tick * 0.08), z: startLoc.z });
            dimension.spawnParticle(runeData.particle, swordEntity.location);
        } 
        else if (tick === 30) {
            const newSword = swordStack.clone();
            let lore = newSword.getLore() || [];
            let existingIndex = lore.findIndex(l => l.includes(runeData.name));
            let currentSockets = lore.filter(l => l.includes("Rune")).length;

            if (existingIndex !== -1) {
                let level = Math.min(getRuneLevel(lore[existingIndex]) + 1, MAX_RUNE_LEVEL);
                lore[existingIndex] = `${runeData.color}${runeData.name} Rune ${toRoman(level)}`;
            } else if (currentSockets < MAX_SOCKETS) {
                lore.push(`${runeData.color}${runeData.name} Rune ${toRoman(runeData.level)}`);
            }
            if (isMidas && !lore.some(l => l.includes("Midas"))) lore.push("§6Midas Rune III");

            newSword.setLore(lore);
            const newEntity = dimension.spawnItem(newSword, swordEntity.location);
            swordEntity.remove();
            
            const sound = isMidas ? "random.levelup" : runeData.sound;
            const pitch = isMidas ? 0.5 : 1.0;
            dimension.playSound(sound, newEntity.location, { pitch: pitch });
            dimension.spawnParticle("minecraft:huge_explosion_emitter", newEntity.location);
            
            let driftTick = 0;
            const driftInterval = system.runInterval(() => {
                if (!newEntity.isValid || !player || !player.isValid) { system.clearRun(driftInterval); return; }
                driftTick++;
                const pLoc = player.getHeadLocation();
                const eLoc = newEntity.location;
                const dir = { x: pLoc.x - eLoc.x, y: (pLoc.y - 0.5) - eLoc.y, z: pLoc.z - eLoc.z };
                const dist = Math.sqrt(dir.x**2 + dir.y**2 + dir.z**2);
                
                if (dist < 0.8 || driftTick > 70) {
                    newEntity.applyImpulse({ x: dir.x * 0.2, y: 0.2, z: dir.z * 0.2 });
                    system.clearRun(driftInterval);
                } else {
                    newEntity.teleport({ x: eLoc.x + (dir.x / dist) * 0.15, y: eLoc.y + (dir.y / dist) * 0.15, z: eLoc.z + (dir.z / dist) * 0.15 });
                    dimension.spawnParticle(runeData.particle, newEntity.location);
                }
            }, 1);
            system.clearRun(interval);
        }
    }, 1);
}

system.runInterval(() => {
    for (const player of world.getPlayers()) {
        const inv = player.getComponent(EntityComponentTypes.Inventory).container;
        const item = inv.getItem(player.selectedSlotIndex);
        if (!item) continue;
        const lore = item.getLore();
        if (!lore) continue;

        for (const line of lore) {
            if (!line.includes("Rune")) continue;
            const level = getRuneLevel(line);
            for (const key in RUNES) {
                const rune = RUNES[key];
                if (line.includes(rune.name) && rune.type === 'passive') {
                    player.addEffect(EffectTypes.get(rune.effect), 20, { amplifier: level - 1, showParticles: false });
                    if (rune.name === "Reinforced" && level === 3) player.addEffect(EffectTypes.get("resistance"), 20, { amplifier: 1, showParticles: false });
                    if (rune.name === "Swift" && level === 3) player.addEffect(EffectTypes.get("jump_boost"), 20, { amplifier: 1, showParticles: false });
                }
            }
            if (line.includes("Midas")) {
                player.addEffect(EffectTypes.get("speed"), 20, { amplifier: 1, showParticles: false });
                player.addEffect(EffectTypes.get("resistance"), 20, { amplifier: 0, showParticles: false });
            }
        }
    }
}, 10);

world.afterEvents.entityHitEntity.subscribe((event) => {
    const { damagingEntity, hitEntity } = event;
    if (damagingEntity.typeId !== 'minecraft:player') return;
    const inv = damagingEntity.getComponent(EntityComponentTypes.Inventory).container;
    const item = inv.getItem(damagingEntity.selectedSlotIndex);
    if (!item) return;
    const lore = item.getLore();
    if (!lore) return;

    for (const line of lore) {
        const level = getRuneLevel(line);
        if (line.includes("Charred")) {
            hitEntity.addEffect(EffectTypes.get("wither"), 60 * level, { amplifier: level - 1 });
            if (level === 3) {
                const nearby = hitEntity.dimension.getEntities({ location: hitEntity.location, maxDistance: 3, excludeTypes: ["minecraft:player"] });
                for (const m of nearby) m.addEffect(EffectTypes.get("wither"), 40, { amplifier: 0 });
            }
        }
        if (line.includes("Storm")) {
            hitEntity.dimension.spawnEntity("minecraft:lightning_bolt", hitEntity.location);
            if (level === 3) {
                const second = hitEntity.dimension.getEntities({ location: hitEntity.location, maxDistance: 6, excludeTypes: ["minecraft:player"], closest: 2 })[1];
                if (second) hitEntity.dimension.spawnEntity("minecraft:lightning_bolt", second.location);
            }
        }
        if (line.includes("Midas")) {
            hitEntity.addEffect(EffectTypes.get("slowness"), 40, { amplifier: 3 });
            damagingEntity.dimension.playSound("block.amethyst_block.chime", hitEntity.location, { pitch: 0.5 });
            damagingEntity.dimension.spawnParticle("minecraft:totem_particle", hitEntity.location);
        }
        if (line.includes("Sharp") && level === 3) {
            const health = hitEntity.getComponent("minecraft:health");
            if (health && health.currentValue < health.effectiveMax * 0.25) hitEntity.applyDamage(20);
        }
    }
});

const phoenixCooldown = new Map();
system.runInterval(() => {
    for (const player of world.getPlayers()) {
        const inv = player.getComponent(EntityComponentTypes.Inventory).container;
        const item = inv.getItem(player.selectedSlotIndex);
        if (!item) continue;
        if (item.getLore()?.some(l => l.includes("Vitality Rune III"))) {
            const health = player.getComponent("minecraft:health");
            if (health.currentValue < 8 && (!phoenixCooldown.has(player.id) || system.currentTick > phoenixCooldown.get(player.id))) {
                health.setCurrentValue(health.currentValue + 12);
                player.dimension.playSound("random.totem", player.location);
                player.dimension.spawnParticle("minecraft:totem_particle", player.location);
                phoenixCooldown.set(player.id, system.currentTick + 1200);
            }
        }
    }
}, 10);

import { world, system, EntityComponentTypes, EquipmentSlot, BlockPermutation } from '@minecraft/server';

const LIGHT_BLOCK_ID = 'minecraft:light_block';
const LIGHT_LEVEL = 14;

const LIGHT_SOURCES = [
    'minecraft:torch',
    'minecraft:soul_torch',
    'minecraft:lantern',
    'minecraft:soul_lantern'
];

const lightTracker = new Map();

system.runInterval(() => {
    for (const player of world.getPlayers()) {
        if (!player.isValid) continue;

        const equip = player.getComponent(EntityComponentTypes.Equippable);
        const main = equip.getEquipment(EquipmentSlot.Mainhand);
        const off = equip.getEquipment(EquipmentSlot.Offhand);

        const isHoldingLight = (main && LIGHT_SOURCES.includes(main.typeId)) || 
                               (off && LIGHT_SOURCES.includes(off.typeId));

        const headLoc = player.getHeadLocation();
        const currX = Math.floor(headLoc.x);
        const currY = Math.floor(headLoc.y);
        const currZ = Math.floor(headLoc.z);
        const currDimId = player.dimension.id;

        const lastData = lightTracker.get(player.id);

        if (lastData) {
            const hasMoved = lastData.x !== currX || lastData.y !== currY || lastData.z !== currZ || lastData.dimensionId !== currDimId;

            if (hasMoved || !isHoldingLight) {
                try {
                    const dim = world.getDimension(lastData.dimensionId);
                    const block = dim.getBlock({ x: lastData.x, y: lastData.y, z: lastData.z });

                    if (block && block.permutation.matches(LIGHT_BLOCK_ID)) {
                        block.setPermutation(BlockPermutation.resolve('minecraft:air'));
                    }
                } catch (e) {}
                
                lightTracker.delete(player.id);
            }
        }

        if (isHoldingLight && !lightTracker.has(player.id)) {
            const dim = player.dimension;
            
            try {
                const block = dim.getBlock({ x: currX, y: currY, z: currZ });

                if (block && !block.isLiquid && (block.permutation.matches('minecraft:air') || block.permutation.matches('minecraft:cave_air'))) {
                    
                    const lightPerm = BlockPermutation.resolve(LIGHT_BLOCK_ID)
                        .withState("block_light_level", LIGHT_LEVEL);
                    
                    block.setPermutation(lightPerm);

                    lightTracker.set(player.id, {
                        dimensionId: currDimId,
                        x: currX,
                        y: currY,
                        z: currZ
                    });
                }
            } catch (e) {}
        }
    }
}, 1);

world.afterEvents.playerLeave.subscribe((event) => {
    const lastData = lightTracker.get(event.playerId);
    if (lastData) {
        try {
            const dim = world.getDimension(lastData.dimensionId);
            const block = dim.getBlock({ x: lastData.x, y: lastData.y, z: lastData.z });
            if (block && block.permutation.matches(LIGHT_BLOCK_ID)) {
                block.setPermutation(BlockPermutation.resolve('minecraft:air'));
            }
        } catch (e) {}
        lightTracker.delete(event.playerId);
    }
});

world.afterEvents.entityDie.subscribe((event) => {
    if (event.deadEntity.typeId === 'minecraft:player') {
        const lastData = lightTracker.get(event.deadEntity.id);
        if (lastData) {
            try {
                const dim = world.getDimension(lastData.dimensionId);
                const block = dim.getBlock({ x: lastData.x, y: lastData.y, z: lastData.z });
                if (block && block.permutation.matches(LIGHT_BLOCK_ID)) {
                    block.setPermutation(BlockPermutation.resolve('minecraft:air'));
                }
            } catch (e) {}
            lightTracker.delete(event.deadEntity.id);
        }
    }
});

import { world, system, EntityComponentTypes, EquipmentSlot } from '@minecraft/server';

const TRIGGER_ITEM = 'minecraft:wooden_sword';
const ARROW_SPEED = 1.5;
const TURN_SPEED = 0.2;
const SEARCH_RADIUS = 15;
const HOMING_TAG = 'custom_homing_arrow';

world.afterEvents.itemUse.subscribe((event) => {
    const { source: player, itemStack } = event;

    if (itemStack.typeId === TRIGGER_ITEM) {
        const dim = player.dimension;
        const headLoc = player.getHeadLocation();
        const viewDir = player.getViewDirection();

        const spawnPos = {
            x: headLoc.x + (viewDir.x * 1.5),
            y: headLoc.y + (viewDir.y * 1.5),
            z: headLoc.z + (viewDir.z * 1.5)
        };

        try {
            const arrow = dim.spawnEntity("minecraft:arrow", spawnPos);
            
            arrow.addTag(HOMING_TAG);

            const projComp = arrow.getComponent("minecraft:projectile");
            if (projComp) {
                projComp.owner = player;
                projComp.shoot({
                    x: viewDir.x * ARROW_SPEED,
                    y: viewDir.y * ARROW_SPEED,
                    z: viewDir.z * ARROW_SPEED
                });
            } else {
                arrow.applyImpulse({
                    x: viewDir.x * ARROW_SPEED,
                    y: viewDir.y * ARROW_SPEED,
                    z: viewDir.z * ARROW_SPEED
                });
            }

            player.playSound("random.bow");

        } catch (e) {
        }
    }
});

system.runInterval(() => {
    const overworld = world.getDimension("overworld");
    
    const arrows = overworld.getEntities({ type: 'minecraft:arrow' });

    for (const arrow of arrows) {
        if (!arrow.isValid) continue;

        if (!arrow.hasTag(HOMING_TAG)) continue;

        const targets = overworld.getEntities({
            location: arrow.location,
            maxDistance: SEARCH_RADIUS,
            excludeTypes: ['minecraft:player', 'minecraft:arrow', 'minecraft:item', 'minecraft:xp_orb'],
            closest: 1
        });

        if (targets.length === 0) continue;
        const target = targets[0];

        const arrowLoc = arrow.location;
        const targetLoc = target.location;

        const dx = targetLoc.x - arrowLoc.x;
        const dy = (targetLoc.y + 1.0) - arrowLoc.y;
        const dz = targetLoc.z - arrowLoc.z;

        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
        if (dist === 0) continue;

        const newVel = {
            x: (dx / dist) * ARROW_SPEED,
            y: (dy / dist) * ARROW_SPEED,
            z: (dz / dist) * ARROW_SPEED
        };

        arrow.clearVelocity();
        arrow.applyImpulse(newVel);
        
        overworld.spawnParticle("minecraft:basic_flame_particle", arrowLoc);
    }
}, 1);

import { world, system, EntityComponentTypes, EquipmentSlot } from "@minecraft/server";

const CLIMB_POWER = 0.6;
const WALL_ADHESION = 0.2; 
const MAX_STAMINA = 260; 
const SHIELD_ITEM = 'minecraft:shield';

const wasSneaking = new Map();
const staminaMap = new Map();

system.runInterval(() => {
    for (const player of world.getPlayers()) {
        if (!player.isValid) continue;

        const equip = player.getComponent(EntityComponentTypes.Equippable);
        const main = equip.getEquipment(EquipmentSlot.Mainhand);
        const off = equip.getEquipment(EquipmentSlot.Offhand);
        const hasDualShields = main?.typeId === SHIELD_ITEM && off?.typeId === SHIELD_ITEM;

        if (player.isOnGround) {
            staminaMap.set(player.id, MAX_STAMINA);
        }

        const isSneaking = player.isSneaking;
        const prevSneaking = wasSneaking.get(player.id) || false;
        const view = player.getViewDirection();
        const loc = player.location;

        const len = Math.sqrt(view.x * view.x + view.z * view.z);
        if (len < 0.1) {
            wasSneaking.set(player.id, isSneaking);
            continue;
        }
        const dirX = view.x / len;
        const dirZ = view.z / len;

        let hasWall = false;
        try {
            const blockInFront = player.dimension.getBlock({
                x: loc.x + (dirX * 0.6), 
                y: loc.y + 0.5,
                z: loc.z + (dirZ * 0.6)
            });
            
            if (blockInFront && !blockInFront.isAir && !blockInFront.isLiquid) {
                hasWall = true;
            }
        } catch (e) {}

        let currentStamina = staminaMap.get(player.id) ?? MAX_STAMINA;

        if (hasDualShields && hasWall && !player.isOnGround) {
            if (isSneaking) {
                if (currentStamina > 0) {
                    const vel = player.getVelocity();
                    player.applyImpulse({
                        x: 0,
                        y: 0.08 - vel.y, 
                        z: 0
                    });
                    
                    if (system.currentTick % 10 === 0) {
                        player.dimension.spawnParticle("minecraft:cloud_particle", player.location);
                    }

                    currentStamina--;
                    staminaMap.set(player.id, currentStamina);

                    const percent = currentStamina / MAX_STAMINA;
                    const bars = 20;
                    const filled = Math.ceil(percent * bars);
                    const empty = bars - filled;
                    const seconds = (currentStamina / 20).toFixed(1);
                    
                    let color = "§a";
                    if (percent < 0.5) color = "§e";
                    if (percent < 0.2) color = "§c";

                    const barStr = `${color}${"|".repeat(filled)}§8${"|".repeat(empty)}`;
                    player.onScreenDisplay.setActionBar(`Time to climb: [${barStr}§r] ${color}${seconds}s`);
                } else {
                    player.onScreenDisplay.setActionBar("§c§lFATIGUED");
                }
            }

            if (prevSneaking && !isSneaking && currentStamina > 0) {
                const vel = player.getVelocity();
                player.applyImpulse({
                    x: (dirX * WALL_ADHESION) - vel.x,
                    y: CLIMB_POWER,
                    z: (dirZ * WALL_ADHESION) - vel.z
                });
                player.playSound("step.ladder", { volume: 1.0, pitch: 0.8 });
                
                currentStamina = Math.max(0, currentStamina - 20);
                staminaMap.set(player.id, currentStamina);
            }
        }

        wasSneaking.set(player.id, isSneaking);
    }
});

import { world, system, EntityComponentTypes, EquipmentSlot, EffectTypes } from '@minecraft/server';

system.runInterval(() => {
    for (const player of world.getPlayers()) {
        if (!player.isValid) continue;

        const equip = player.getComponent(EntityComponentTypes.Equippable);
        const boots = equip.getEquipment(EquipmentSlot.Feet);

        if (boots && boots.nameTag === "Slime") {
            const vel = player.getVelocity();
            
            if (vel.y < -0.5) { 
                const loc = player.location;
                const dim = player.dimension;
                
                let groundClose = false;
                try {
                    const b1 = dim.getBlock({ x: loc.x, y: loc.y - 1, z: loc.z });
                    const b2 = dim.getBlock({ x: loc.x, y: loc.y - 2, z: loc.z });
                    const b3 = dim.getBlock({ x: loc.x, y: loc.y - 3, z: loc.z });
                    
                    if ((b1 && !b1.isAir && !b1.isLiquid) || 
                        (b2 && !b2.isAir && !b2.isLiquid) || 
                        (b3 && !b3.isAir && !b3.isLiquid)) {
                        groundClose = true;
                    }
                } catch (e) {}

                if (groundClose) {
                    player.addEffect(EffectTypes.get("resistance"), 2, { amplifier: 255, showParticles: false });
                }
            }
        }
    }
}, 1);

import { world, system, EffectTypes, EasingType } from '@minecraft/server';

const MOB_ID = "pa:toy_freddy_active"; 
const SCREAM_SOUND = "mob.enderdragon.growl"; 

const DURATION_SECONDS = 2.5; 
const TOTAL_TICKS = DURATION_SECONDS * 20;

const START_OFFSET = 0.5;   
const END_OFFSET = 0.4;     
const MOB_EYE_HEIGHT = 2.2; 

const activeJumpscares = new Set();

function lerp(start, end, t) { return start + (end - start) * t; }
function smoothStep(t) { return t * t * (3 - 2 * t); }

world.afterEvents.playerSpawn.subscribe((event) => {
    const player = event.player;
    player.camera.clear();
    try { player.runCommand("fog @s remove jumpscare_fog"); } catch(e) {}
    activeJumpscares.delete(player.id);
});

world.afterEvents.entityHitEntity.subscribe((event) => {
    const { damagingEntity: mob, hitEntity: player } = event;

    if (!mob || !player || mob.typeId !== MOB_ID || player.typeId !== 'minecraft:player') return;
    if (activeJumpscares.has(player.id)) return;

    runManualJumpscare(player, mob);
});

function runManualJumpscare(player, mob) {
    activeJumpscares.add(player.id);
    const dimension = player.dimension;

    try {
        try {
            mob.addEffect(EffectTypes.get("slowness"), TOTAL_TICKS + 60, { amplifier: 255, showParticles: false });
            mob.addEffect(EffectTypes.get("weakness"), TOTAL_TICKS + 60, { amplifier: 255, showParticles: false });
        } catch(e) {}

        try { player.runCommand("fog @s push minecraft:fog_the_end jumpscare_fog"); } catch(e) {}
        
        player.camera.fade({
            fadeTime: { fadeInTime: DURATION_SECONDS, holdTime: 3.0, fadeOutTime: 1.0 },
            fadeColor: { red: 0, green: 0, blue: 0 }
        });

        player.playSound(SCREAM_SOUND, { volume: 1.0, pitch: 1.0 });

        const playerHead = player.getHeadLocation();
        const viewDir = player.getViewDirection();
        const startPos = {
            x: playerHead.x + (viewDir.x * START_OFFSET),
            y: playerHead.y + (viewDir.y * START_OFFSET),
            z: playerHead.z + (viewDir.z * START_OFFSET)
        };

        let currentTick = 0;

        const frameInterval = system.runInterval(() => {
            if (!player.isValid || !mob.isValid) {
                system.clearRun(frameInterval);
                finishJumpscare(player);
                return;
            }

            const mobPos = mob.location;
            const dx = mobPos.x - playerHead.x;
            const dy = (mobPos.y + MOB_EYE_HEIGHT) - playerHead.y;
            const dz = mobPos.z - playerHead.z;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            const dirX = dx / dist;
            const dirY = dy / dist;
            const dirZ = dz / dist;

            const endPos = {
                x: mobPos.x - (dirX * END_OFFSET),
                y: (mobPos.y + MOB_EYE_HEIGHT) - (dirY * END_OFFSET),
                z: mobPos.z - (dirZ * END_OFFSET)
            };

            const lookAt = { x: mobPos.x, y: mobPos.y + MOB_EYE_HEIGHT, z: mobPos.z };

            let progress = currentTick / TOTAL_TICKS;
            let t = smoothStep(progress); 

            const currentPos = {
                x: lerp(startPos.x, endPos.x, t),
                y: lerp(startPos.y, endPos.y, t),
                z: lerp(startPos.z, endPos.z, t)
            };

            player.camera.setCamera("minecraft:free", {
                location: currentPos,
                facingLocation: lookAt,
                easeOptions: { easeType: EasingType.Linear, time: 0.05 }
            });

            mob.teleport(mob.location, { dimension: dimension, facingLocation: playerHead });

            currentTick++;

            if (currentTick >= TOTAL_TICKS) {
                system.clearRun(frameInterval);
                finishJumpscare(player);
            }
        }, 1);

    } catch (error) {
        finishJumpscare(player);
    }
}

function finishJumpscare(player) {
    try { player.runCommand("fog @s remove jumpscare_fog"); } catch(e) {}

    system.runTimeout(() => {
        if (!player.isValid) return;
        
        player.camera.clear();
        activeJumpscares.delete(player.id);

        system.runTimeout(() => {
            if (!player.isValid) return;
            player.kill();
        }, 10);
    }, 5);
}

import { world, system, EntityComponentTypes, EquipmentSlot, EffectTypes } from '@minecraft/server';

const BASE_SPEED = 0.75;       
const SPRINT_BOOST = 1.275;    
const VERTICAL_SPEED = 0.6;    
const ACCELERATION = 0.2;      
const BRAKING = 0.15;          
const DOUBLE_TAP_WINDOW = 7;

const ALLOWED_CHESTPLATES = [
    'minecraft:leather_chestplate',
    'minecraft:iron_chestplate',
    'minecraft:golden_chestplate',
    'minecraft:diamond_chestplate',
    'minecraft:netherite_chestplate'
];

const flyingPlayers = new Set();
const jumpState = new Map(); 
const lastJumpTick = new Map();

system.runInterval(() => {
    const currentTick = system.currentTick;

    for (const player of world.getPlayers()) {
        if (!player.isValid) continue;

        const equip = player.getComponent(EntityComponentTypes.Equippable);
        const chest = equip.getEquipment(EquipmentSlot.Chest);
        const hasArmor = chest && ALLOWED_CHESTPLATES.includes(chest.typeId);

        const isJumping = player.isJumping;
        const wasJumping = jumpState.get(player.id) || false;
        
        if (isJumping && !wasJumping && hasArmor) {
            const lastTap = lastJumpTick.get(player.id) || 0;
            
            if (currentTick - lastTap <= DOUBLE_TAP_WINDOW) {
                if (flyingPlayers.has(player.id)) {
                    flyingPlayers.delete(player.id);
                    player.playSound("armor.equip_elytra");
                } else if (!player.isOnGround) {
                    flyingPlayers.add(player.id);
                    player.playSound("armor.equip_elytra");
                    player.applyImpulse({ x: 0, y: 0.6, z: 0 });
                }
                lastJumpTick.set(player.id, 0);
            } else {
                lastJumpTick.set(player.id, currentTick);
            }
        }
        jumpState.set(player.id, isJumping);

        if (!hasArmor && flyingPlayers.has(player.id)) {
            flyingPlayers.delete(player.id);
        }

        if (flyingPlayers.has(player.id)) {
            const input = player.inputInfo.getMovementVector();
            const viewDir = player.getViewDirection();
            const currentVel = player.getVelocity();
            
            const forwardVec = viewDir; 

            const hLen = Math.sqrt(viewDir.x**2 + viewDir.z**2) || 1;
            const flatForward = { x: viewDir.x / hLen, z: viewDir.z / hLen };
            const rightVec = { x: flatForward.z, z: -flatForward.x }; 

            let speed = BASE_SPEED;
            if (player.isSprinting) speed *= SPRINT_BOOST;

            let targetX = (forwardVec.x * input.y * speed) + (rightVec.x * input.x * speed);
            let targetY = (forwardVec.y * input.y * speed); 
            let targetZ = (forwardVec.z * input.y * speed) + (rightVec.z * input.x * speed);

            if (player.isJumping) targetY += VERTICAL_SPEED;
            if (player.isSneaking) targetY -= VERTICAL_SPEED;

            if (input.y === 0 && !player.isJumping && !player.isSneaking) {
                targetY = 0.06; 
            }

            const factor = (input.x === 0 && input.y === 0) ? BRAKING : ACCELERATION;

            const impulseX = (targetX - currentVel.x) * factor;
            const impulseY = (targetY - currentVel.y) * 0.5; 
            const impulseZ = (targetZ - currentVel.z) * factor;

            player.applyImpulse({ x: impulseX, y: impulseY, z: impulseZ });
            
            if (player.isSprinting && (input.x !== 0 || input.y !== 0) && system.currentTick % 3 === 0) {
                try { player.dimension.spawnParticle("minecraft:electric_spark_particle", player.location); } catch(e){}
            }
        }

        if (hasArmor) {
            const vel = player.getVelocity();
            if (vel.y < -0.5) { 
                const loc = player.location;
                const dim = player.dimension;
                
                let groundClose = false;
                try {
                    const b1 = dim.getBlock({ x: loc.x, y: loc.y - 1, z: loc.z });
                    const b2 = dim.getBlock({ x: loc.x, y: loc.y - 2, z: loc.z });
                    const b3 = dim.getBlock({ x: loc.x, y: loc.y - 3, z: loc.z });
                    
                    if ((b1 && !b1.isAir && !b1.isLiquid) || 
                        (b2 && !b2.isAir && !b2.isLiquid) || 
                        (b3 && !b3.isAir && !b3.isLiquid)) {
                        groundClose = true;
                    }
                } catch (e) {}

                if (groundClose) {
                    player.addEffect(EffectTypes.get("resistance"), 2, { amplifier: 255, showParticles: false });
                }
            }
        }
    }
}, 1);

import { world, system, EntityComponentTypes, EquipmentSlot } from '@minecraft/server';

const WEAPON_ID = 'minecraft:netherite_sword';
const TRIGGER_ITEM = 'minecraft:fire_charge';
const BUFF_DURATION = 200; 
const SPEED_FORCE = 0.0075; 
const EXTRA_DAMAGE = 6; 
const BURN_DURATION = 5; 

const recentFireCharge = new Map(); 
const activeBuffs = new Map();      

world.afterEvents.itemStartUseOn.subscribe((event) => {
    const { source, itemStack } = event;
    
    if (itemStack && itemStack.typeId === TRIGGER_ITEM) {
        recentFireCharge.set(source.id, system.currentTick + 100);
    }
});

world.afterEvents.entityHurt.subscribe((event) => {
    const { hurtEntity, damageSource } = event;

    if (hurtEntity.typeId !== 'minecraft:player') return;

    if (damageSource.cause === 'fire' || damageSource.cause === 'fire_tick' || damageSource.cause === 'lava') {
        
        const currentTick = system.currentTick;
        const expiry = recentFireCharge.get(hurtEntity.id);

        if (expiry && currentTick < expiry) {
            
            const equip = hurtEntity.getComponent(EntityComponentTypes.Equippable);
            const mainHand = equip?.getEquipment(EquipmentSlot.Mainhand);

            if (mainHand && mainHand.typeId === WEAPON_ID) {
                activateBuff(hurtEntity);
                recentFireCharge.delete(hurtEntity.id);
            }
        }
    }
});

function activateBuff(player) {
    activeBuffs.set(player.id, system.currentTick + BUFF_DURATION);
    player.playSound("mob.blaze.shoot");
    player.sendMessage("§6§lFLAMEHEART ACTIVATED!");
    player.extinguishFire(true);
}

system.runInterval(() => {
    const currentTick = system.currentTick;

    for (const [playerId, expiry] of activeBuffs) {
        const player = world.getEntity(playerId);

        if (!player || !player.isValid || currentTick > expiry) {
            activeBuffs.delete(playerId);
            if (player && player.isValid) player.sendMessage("§cFlameheart faded.");
            continue;
        }

        if (player.isSprinting) { 
            const view = player.getViewDirection();
            player.applyImpulse({
                x: view.x * SPEED_FORCE,
                y: 0,
                z: view.z * SPEED_FORCE
            });
        }

        try {
            player.dimension.spawnParticle("minecraft:basic_flame_particle", player.location);
        } catch (e) {}
    }
});

world.afterEvents.entityHitEntity.subscribe((event) => {
    const { damagingEntity, hitEntity } = event;

    if (damagingEntity.typeId !== 'minecraft:player') return;

    if (activeBuffs.has(damagingEntity.id)) {
        
        const healthComp = hitEntity.getComponent(EntityComponentTypes.Health);
        if (healthComp) {
            const newHealth = Math.max(0, healthComp.currentValue - EXTRA_DAMAGE);
            healthComp.setCurrentValue(newHealth);
        }

        hitEntity.setOnFire(BURN_DURATION, true);
        
        damagingEntity.dimension.spawnParticle("minecraft:lava_particle", hitEntity.location);
        damagingEntity.dimension.playSound("mob.ghast.fireball", damagingEntity.location, { pitch: 1.5 });
    }
});

import { world, system } from "@minecraft/server";

const CLIMB_POWER = 0.6;
const WALL_ADHESION = 0.2; 

const wasSneaking = new Map();

system.runInterval(() => {
    for (const player of world.getPlayers()) {
        const isSneaking = player.isSneaking;
        const prevSneaking = wasSneaking.get(player.id) || false;
        const view = player.getViewDirection();
        const loc = player.location;

        const len = Math.sqrt(view.x * view.x + view.z * view.z);
        if (len < 0.1) {
            wasSneaking.set(player.id, isSneaking);
            continue;
        }
        const dirX = view.x / len;
        const dirZ = view.z / len;

        let hasWall = false;
        try {
            const blockInFront = player.dimension.getBlock({
                x: loc.x + (dirX * 0.6), 
                y: loc.y + 0.5,
                z: loc.z + (dirZ * 0.6)
            });
            
            if (blockInFront && !blockInFront.isAir && !blockInFront.isLiquid) {
                hasWall = true;
            }
        } catch (e) {}

        if (isSneaking && hasWall && !player.isOnGround) {
            const vel = player.getVelocity();
            
            player.applyImpulse({
                x: 0,
                y: 0.08 - vel.y, 
                z: 0
            });
            
            if (system.currentTick % 10 === 0) {
                player.dimension.spawnParticle("minecraft:cloud_particle", player.location);
            }
        }

        if (prevSneaking && !isSneaking && hasWall) {
            const vel = player.getVelocity();
            player.applyImpulse({
                x: (dirX * WALL_ADHESION) - vel.x,
                y: CLIMB_POWER,
                z: (dirZ * WALL_ADHESION) - vel.z
            });
            player.playSound("step.ladder", { volume: 1.0, pitch: 0.8 });
        }

        wasSneaking.set(player.id, isSneaking);
    }
});

And you'll use https://learn.microsoft.com/en-us/minecraft/creator/scriptapi/minecraft/server/minecraft-server?view=minecraft-bedrock-stable and https://learn.microsoft.com/en-us/minecraft/creator/scriptapi/minecraft/server-ui/minecraft-server-ui?view=minecraft-bedrock-stable and https://jaylydev.github.io/scriptapi-docs/latest/modules/_minecraft_server-1.html for your documents and resources n stuff. (My server version in scripting api is 2.5.0-beta, which is the docs for jayly. But for microsoft its stable and beta combined.) ALWAYS SEARCH FIRST if actually necessary! 2.5.0-beta is the latest scripting. I use 2.5.0-beta.
